# NestAPI

API backend service with RESTful and GrapQL based on Nest.js, TypeORM, Apollo

Этот бэк предоставляет уже готовые базовые возможности:

- управление регистрацией и авторизацией/аутентификацей пользователей,
- получение и обработка файлов, в т.ч. изображений,
- работа с базой данных,
- RestAPI и GraphQL в любом сочетании по выбору.

Для примера бэк уже содержит несколько базовых сущностей. Обычно они нужны в любой системе в том или ином виде, так что вы можете использовать их не только в качестве примера, но и для работы.

# TO DO

Мы практически полностью убрали из кода слой представления (за исключением почтовых шаблонов). Он должен быть реализован на стороне фронтэнда.

Почтовый сервис будет выделен в отдельный сервис со своим API. Сейчас он все еще существует здесь, чтобы поддерживать процесс регистрации и авторизации в части отправки на электронную почту уведомлений, а также кодов подтверждения.

Вместе с почтовым сервисом будет убрана оставшаяся часть слоя представления.

Далее (проверяем/делаем):

- auth register -> create
- сделать/вернуть сессии при входе через формы, чтобы запоминался токен, рефреш кажется, и проверялся в сессии

- убрать:
- возможно, сделать сервисы из FormsAuthService по типу login:

  - если !redirect_uri || !client_id || !response_type, то возвращается значение без редиректа

- если в форму авторизации был передан redirect_uri, то он записывается в куки
  это сделано для механизма сервера авторизации,
  чтобы после возврата значений из других сервисов авторизации на сервер авторизации
  сам сервер авторизации возвращал полученные значения клиенту
  сессиями это сделать не удалось, т.к. после редиректа из сервисов авторизации
  стартуется новая сессия, а старая теряется
  так вот, эти куки записываются при наличии redirect_uri, а в случае отсутствия redirect_uri не чистятся

# Оглавление

- [Установка](#установка)
- [Запуск](#запуск)
- [Настройка](#настройка)
  - [Настройки сервера](#настройки-сервера)
  - [Настройки загрузки](#настройки-загрузки)
  - [Настройки документации](#настройки-документации)
  - [Настройки сессии](#настройки-сессии)
  - [Настройки шифрования](#настройки-шифрования)
  - [Настройки токенов](#настройки-токенов)
  - [Настройки базы данных](#настройки-базы-данных)
  - [Настройки GraphQL](#настройки-graphql)
  - [Настройки почты](#настройки-почты)
  - [Настройки стратегий авторизации](#настройки-стратегий-авторизации)
- [Базовые сущности](#базовые-сущности)
  - [Типы сущностей](#типы-сущностей)
  - [Расширение типов сущностей](#расширение-типов-сущностей)
- [Отношения](#отношения)
  - [Один-к-одному](#один-к-одному)
  - [Один-ко-многим и многие-к-одному](#один-ко-многим-и-многие-к-одному)
  - [Многие-ко-многим](#многие-ко-многим)
  - [Каскады](#каскады)
  - [Пример построения](#пример-построения)
- [Модель данных](#модель-данных)
  - [Защита модели данных](#защита-модели-данных)
  - [Описание модели данных](#описание-модели-данных)
  - [Настройка модели данных](#настройка-модели-данных)
  - [Генерация модели данных](#генерация-модели-данных)
  - [Защита полей](#защита-полей)
- [Контроллеры и резолверы](#контроллеры-и-резолверы)
  - [Аргументы запросов](#аргументы-запросов)
  - [Методы запросов](#методы-запросов)
  - [Пути запросов](#пути-запросов)
- [Сервисы](#сервисы)
  - [Объединение сервисов](#объединение-сервисов)
- [Методы](#методы)
  - [Базовые методы](#базовые-методы)
    - [Метод find](#метод-find)
    - [Метод findOne](#метод-findone)
    - [Метод first](#метод-first)
    - [Метод findMany](#метод-findmany)
    - [Метод self](#метод-self)
    - [Метод create](#метод-create)
    - [Метод update](#метод-update)
    - [Метод remove](#метод-remove)
  - [Опции](#опции)
    - [Опции отношений](#опции-отношений)
    - [Опции фильтрации](#опции-фильтрации)
    - [Опции группировки](#опции-группировки)
    - [Опции технически](#опции-технически)
  - [Наследование методов](#наследование-методов)
    - [Наследование контроллера](#наследование-контроллера)
    - [Наследование резолвера](#наследование-резолвера)
    - [Наследование сервисов](#наследование-сервисов)
- [Работа с файлами](#работа-с-файлами)
  - [filesSave](#filessave)
  - [filesRename](#filesrename)
  - [filesMaxSize](#filesmaxsize)
  - [filesAllowTypes](#filesallowtypes)
  - [filesIsImage](#filesisimage)
  - [filesImageMetadata](#filesimagemetadata)
  - [filesImageResize](#filesimageresize)
  - [filesImageOversize](#filesimageoversize)
  - [convertToWebp](#converttowebp)
  - [filesImageConvert](#filesimageconvert)
  - [Интерфейс файла](#интерфейс-файла)
- [Работа с почтой](#работа-с-почтой)
  - [mailSend](#mailsend)
  - [Интерфейс файла](#интерфейс-файла)
- [Работа с базой данных](#работа-с-базой-данных)
- [Шифрование](#шифрование)
  - [encrypt](#encrypt)
  - [decrypt](#decrypt)
  - [hash](#hash)
- [Рандомайзеры](#рандомайзеры)
  - [random](#random)
  - [randomString](#randomstring)
  - [randomSet](#randomset)
  - [randomNum](#randomnum)
  - [randomBin](#randombin)
  - [randomHex](#randomhex)
  - [randomArray](#randomarray)
  - [shuffleArray](#shufflearray)
  - [randomOption](#randomoption)
  - [randomEmail](#randomemail)
  - [randomName](#randomname)
- [Авторизация](#авторизация)
  - [Данные авторизации](#данные-авторизации)
  - [Протокол авторизации](#протокол-авторизации)
  - [Термины протокола авторизации](#термины-протокола-авторизации)
  - [Процессы протокола авторизации](#процессы-протокола-авторизации)
  - [Процесс авторизации](#процесс-авторизации)
    - [Процесс авторизации на клиенте](#процесс-авторизации-на-клиенте)
    - [Схема процесса авторизации на сервере](#схема-процесса-авторизации-на-сервере)
    - [Авторизация клиента на сервере](#авторизация-клиента-на-сервере)
    - [Авторизация пользователя на сервере](#авторизация-пользователя-на-сервере)
    - [Передача кода авторизации](#передача-кода-авторизации)
    - [Передача токена доступа](#передача-токена-доступа)
  - [Методы авторизации](#методы-авторизации)
    - [Метод авторизации authorization code](#метод-авторизации-authorization-code)
    - [Метод авторизации implicit grant](#метод-авторизации-implicit-grant)
    - [Метод входа в систему](#метод-входа-в-систему)
    - [Метод регистрации](#метод-регистрации)
    - [Механизм подтверждения регистрации](#механизм-подтверждения-регистрации)
    - [Метод подтверждения регистрации](#метод-подтверждения-регистрации)
    - [Запрос на восстановления пароля](#запрос-на-восстановления-пароля)
    - [Метод восстановления пароля](#метод-восстановления-пароля)
- [Клиентские приложения](#клиентские-приложения)
  - [Данные клиента](#данные-клиента)
  - [Декораторы клиента](#декораторы-клиента)
  - [Регистрация клиента](#регистрация-клиента)
- [Роли и права](#роли-и-права)
- [Сессии](#сессии)
  - [Информация о сессии](#информация-о-сессии)
  - [Проверка сессии](#проверка-сессии)
- [Стратегии авторизации](#стратегии-авторизации)
  - [Декораторы методов](#декораторы-методов)
  - [Декораторы аргументов](#декораторы-аргументов)
  - [Защитники](#защитники)
  - [Стратегии](#стратегии)
  - [Подключение сервиса google](#подключение-сервиса-google)
- [Токены](#токены)
  - [Токен доступа](#токен-доступа)
  - [Токен обновления](#токен-обновления)
  - [Проверка токенов](#проверка-токенов)
  - [Методы токенов](#методы-токенов)
    - [Получение токена доступа по типу password](#получение-токена-доступа-по-типу-password)
    - [Получение токена доступа по типу refresh token](#получение-токена-доступа-по-типу-refresh-token)
    - [Получение токена доступа по типу сlient credentials](#получение-токена-доступа-по-типу-сlient-credentials)
    - [Получение токена доступа по типу person credentials](#получение-токена-доступа-по-типу-person-credentials)
    - [Получение токена доступа по типу authorization code](#получение-токена-доступа-по-типу-authorization-code)
- [Персонажи](#персонажи)
  - [Данные персонажа](#данные-персонажа)
  - [Декораторы персонажа](#декораторы-персонажа)
  - [Регистрация персонажа](#регистрация-персонажа)
  - [Авторизация персонажа](#авторизация-персонажа)
  - [Привязка персонажей к суперпользователю](#привязка-персонажей-к-суперпользователю)
- [Сокеты](#сокеты)
- [Комнаты](#комнаты)
- [Настройки](#настройки)
  - [Группы настроек](#группы-настроек)
- [Документация](#документация)
- [Правила именований](#правила-именований)
  - [Обычное именование](#обычное-именование)
  - [Именование в базах данных](#именование-в-базах-данных)
  - [Именование сущностей булевого типа](#именование-сущностей-булевого-типа)
  - [Именование действий](#именование-действий)
  - [Именование определений](#именование-определений)
  - [Полное и краткое именование](#полное-и-краткое-именование)
  - [Именование файлов](#именование-файлов)
  - [Именование модулей](#именование-модулей)
    - [Пример для posts](#пример-для-posts)
    - [Пример для posts_categories](#пример-для-posts_categories)
    - [Внутренняя структура](#внутренняя-структура)

# Установка

Выполните клонирование данного репозитория в ваш проект на локальном компьютере:

```shell script
git clone https://github.com/isengine/nestapi
```

или в текущий каталог вашего проекта:

```shell script
git clone https://github.com/isengine/nestapi .
```

Для сборки и запуска проекта мы рекомендуем использовать менеджер **npm**.

```shell script
npm install
```

[^ к оглавлению](#оглавление)

# Запуск

Для сборки и запуска в режиме разработки, выполните:

```shell script
npm run dev
```

или

```shell script
yarn dev
```

Для сборки в режиме **production**, выполните:

```shell script
npm run build
```

или

```shell script
yarn build
```

Для **production** мы рекомендуем использовать менеджер процессов **pm2**.

Запуск процесса:

```shell script
pm2 start dist/main.js --name nestapi
```

Перезапуск процесса:

```shell script
pm2 reload nestapi
```

Остановка процесса:

```shell script
pm2 stop nestapi
```

Мониторинг процессов:

```shell script
pm2 monit
```

Просмотр логов:

```shell script
pm2 logs nestapi --lines 1000
```

Очистить все процессы:

```shell script
pm2 kill
```

Для запуска без **pm2**, выполните:

```shell script
npm run prod
```

или

```shell script
yarn prod
```

> Мы предлагаем использовать **npm**, т.к. конкретно с **Nest.js** он работает стабильнее чем **yarn**.

[^ к оглавлению](#оглавление)

# Настройка

Настройка бэка производится переменными окружения, которые лежат в файле **.env**. Этот файл небезопасно хранить в репозитории, поэтому мы предлагаем файл с примерным содержанием настроек **.env.example**.

Переименуйте или скопируйте файл **.env.example** в **.env**, а затем настройте его под ваш проект.

Некоторые настройки предусматривают значения вкл/выкл. В этом случае для включения можно использовать значение **true**, а для выключения оставить поле пустым.

Этот файл условно разделен на несколько частей.

[^ к оглавлению](#оглавление)

## Настройки сервера

- NODE_ENV - задает режим работы: **development** или **production**,
- IP - адрес, на котором будет запускаться бэк, по-умолчанию (если не указан) **localhost**,
- PORT - порт, на котором будет запускаться бэк, по-умолчанию **5000**,
- PREFIX - здесь вы можете задать глобальный префикс, например **api** и тогда бэк будет доступен по адресу **http://localhost/api**,
- ROOT_PATH - корневая папка для файлов, по-умолчанию пустая **/**.

[^ к оглавлению](#оглавление)

## Настройки загрузки

- UPLOADS_PATH - каталог для загрузки файлов в корневом каталоге, по-умолчанию **/public/uploads**,
- UPLOADS_URL - путь для формирования ссылки к загруженному файлу в корневом каталоге, по-умолчанию **/uploads**,
- UPLOADS_ALLOW_TYPES - разрешенные для загрузки mime-типы файлов, перечисляются через точку с запятой, по-умолчанию пусто, т.е. разрешены любые типы,
- UPLOADS_MAX_SIZE - максимально допустимый размер файла для загрузки, в байтах, если не задано, то без ограничений, по-умолчанию **1048576**, т.е. **1 МБ**,
- UPLOADS_IMAGE_MAX_WIDTH - максимально допустимая ширина загружаемого изображения, при превышении изображение будет сжато до этих размеров, если не задано, то без ограничений, по-умолчанию **3840**,
- UPLOADS_IMAGE_MAX_HEIGHT - максимально допустимая высота загружаемого изображения, при превышении изображение будет сжато до этих размеров, если не задано, то без ограничений, по-умолчанию **2160**.

[^ к оглавлению](#оглавление)

# Настройки документации

- SWAGGER_PREFIX - относительный путь, по которому будет доступна документация в формате Swagger,
- SWAGGER_PREFIX_REDOC - относительный путь, по которому будет доступна документация в формате ReDoc,
- SWAGGER_TITLE - заголовок документации,
- SWAGGER_DESCRIPTION - описание документации,
- SWAGGER_VERSION - версия документации.

[^ к оглавлению](#оглавление)

## Настройки сессии

- SESSION_SECRET - здесь должна быть любая строка из случайного количества символов, которая является ключом для механизма сессий,
- SESSION_EXPIRES=2592000 - срок жизни сессии в секундах. Желательно, чтобы он был не больше, чем **JWT_REFRESH_EXPIRES**. По-умолчанию равен 30 дням.

[^ к оглавлению](#оглавление)

## Настройки шифрования

- AES_SECRET - ключ шифрования длиной строго 32 символа.

[^ к оглавлению](#оглавление)

## Настройки токенов

- JWT_SECRET - любая строка из случайных символов, является солью для всех jwt токенов,
- JWT_ACCESS_EXPIRES - время действия токена доступа,
- JWT_REFRESH_EXPIRES - время действия токена обновления,
- JWT_CLIENTS_EXPIRES - время действия токена клиента,
- JWT_EXPIRES - активация проверки времени действия токенов.

[^ к оглавлению](#оглавление)

## Настройки базы данных

- DB_TYPE - тип базы данных,
- DB_HOST - хост,
- DB_NAME - имя базы данных,
- DB_USER - имя пользователя для подключения к базе данных,
- DB_PASSWORD - пароль для подключения к базе данных,
- DB_PORT - порт, на котором доступна база данных,
- DB_QUOTES - символ экранирования таблиц и полей в базе данных,
- DB_SYNCHRONIZE - автоматическая синхронизация базы данных со схемой **TypeORM**, по-умолчанию включена, рекомендуем отключать в **production**,
- DB_LOG - логирование и вывод запросов из базы данных, по-умолчанию включен, рекомендуем отключать в **production**.

В файле **.env.example** имеются базовые настройки для подключения к базе данных **MySql** и **Postgres**.

[^ к оглавлению](#оглавление)

## Настройки GraphQL

- GQL_ENABLE - разрешает использовать GraphQL,
- GQL_PLAYGROUND - разрешает использовать песочницу, которая доступна по адресу **graphql**.

По-умолчанию обе настройки влючены.

[^ к оглавлению](#оглавление)

## Настройки почты

- SMTP_HOST - хост для почты,
- SMTP_PORT - порт для почты,
- SMTP_USER - имя пользователя для подключения к почте,
- SMTP_PASSWORD - пароль для подключения к почте,
- SMTP_SECURE - режим защищенности почты,
- SMTP_SENDER_NAME - имя, от которого будет отправляться почта (может быть пустым),
- SMTP_SENDER_EMAIL - email, который будет вписан в отправителя (обычно совпадает с именем пользователя).

[^ к оглавлению](#оглавление)

## Настройки стратегий авторизации

- OAUTH_SERVER - url сервера авторизации.

Вы можете использовать этот бэкенд для создания своего сервера авторизации. Другие приложения на этом бэкенде смогут подключаться к нему по протоколу OAuth 2.0.

Для этих целей нужно задать следующие поля:

```
OAUTH_CLIENT_ID=oauth_client_id
OAUTH_CLIENT_SECRET=oauth_client_secret
OAUTH_CLIENT_REDIRECT=https://localhost:5000/auth/strategies/oauth/redirect
```

Далее хранятся различные настройки, которые вы должны взять из своих аккаунтов на сервисах типа Google authentication.

Например:

```
GOOGLE_CLIENT_ID=google_client_id
GOOGLE_CLIENT_SECRET=google_client_secret
GOOGLE_CLIENT_CALLBACK=http://localhost:5000/auth/strategies/google/redirect
```

[^ к оглавлению](#оглавление)

# Базовые сущности

- categories - категории или разделы постов
- posts - посты
- tags - теги для постов

Каждая сущность имеет базовые поля, такие как:

- bigint
- date
- enum
- int
- text
- timestamp
- varchar

[^ к оглавлению](#оглавление)

## Типы сущностей

У каждой сущности есть несколько типов:

- controller
- DTO
- entity
- module
- resolver
- service

Дополнительными типами могут быть:

- decrator
- enum
- group
- interface

Также вы можете создать любой нужный вам тип.

Каждый тип сущности представлен в файле, который имеет условный шаблон **сущность.тип.ts**.

[^ к оглавлению](#оглавление)

## Расширение типов сущностей

Один тип сущности может отвечать как за один метод, так и объединять несколько методов общего вида или значения.

Если вы хотите расширить сущность, вам нужно решать, что лучше:

- создать новый тип,
- расширить существующий тип.

Если вы хотите создать собственные кастомные типы, предлагаем сделать это в отдельном файле, например **сущность.custom.тип.ts**.

Если типов много, вы можете положить их в отдельный каталог. Например:

    сущность
        тип
            сущность.first.тип.ts
            сущность.second.тип.ts

> Не забудьте в этом случае следить за импортами!

[^ к оглавлению](#оглавление)

# Отношения

Между двумя таблицами могут быть следующие виды отношений:

- one-to-one - один-к-одному,
- one-to-many - один-ко-многим,
- many-to-one - многие-к-одному,
- many-to-many - многие-ко-многим.

Все отношения прописаны в файлах **entity**.

Вы можете поменять существующие отношения или добавить новые.

[^ к оглавлению](#оглавление)

## Один-к-одному

Когда у вас в родительской таблице каждая запись может иметь связь только с одной записью из дочерней таблицы.

| parent_table.id | child_table.id | child_table.parent_id |
| --------------- | -------------- | --------------------- |
| 0               | 0              | 0                     |
| 1               | 1              | 1                     |
| 2               | 2              | 2                     |

Родительская сущность

```
  @OneToOne(
    () => ChildEntity,
    (сhild) => сhild.parent,
    {
      cascade: true
    }
  )
  сhild: ChildEntity;
```

Дочерняя сущность

```
  @OneToOne(
    () => ParentEntity
    (parent) => parent.сhild,
    {
      onDelete: 'CASCADE',
      onUpdate: 'CASCADE'
    }
  )
  @JoinColumn({ name: 'parent_id', referencedColumnName: 'id' })
  parent: ParentEntity;
```

DTO Родителя

```
  @Field(() => ChildDto, { nullable: true })
  child?: ChildDto;
```

DTO Дочерней сущности

```
  @Field(() => ParentDto, { nullable: true })
  parent?: ParentDto;
```

В данном решении дочерняя сущность управляется родителем.

Если вы хотите сделать равноправную связь, вам нужно связать родителя с дочерней сущностью:

```
  @OneToOne(
    () => ChildEntity,
    (сhild) => сhild.parent,
    {
      cascade: true,
      onDelete: 'CASCADE',
      onUpdate: 'CASCADE'
    }
  )
  @JoinColumn({ name: 'child_id', referencedColumnName: 'id' })
  сhild: ChildEntity;
```

Управление сущностями полностью аналогично отношению один-ко-многим.

[^ к оглавлению](#оглавление)

## Один-ко-многим и многие-к-одному

Когда у вас в родительской таблице каждая запись может иметь связи с несколькими записями из дочерней таблицы.

Например, родительская таблица представляет собой таблицу категорий. Каждой записи из дочерней таблицы может быть присвоена только одна категория. Но каждая категория может содержать несколько дочерних записей. При этом некоторым дочерним записям может быть вообще не присвоено ни одной категории.

| parent_table.id | child_table.id | child_table.parent_id |
| --------------- | -------------- | --------------------- |
| 0               | 0              | 0                     |
| 1               | 1              | 1                     |
|                 | 2              | 1                     |
| 2               | 3              | 2                     |
|                 | 4              | 2                     |
|                 | 5              | 2                     |

Родительская таблица будет иметь отношения один-ко-многим, а дочерняя - многие-к-одному.

Родительская сущность

```
  @OneToMany(
    () => ChildEntity,
    (сhild) => сhild.parent,
    {
      cascade: true
    }
  )
  сhildren: ChildEntity[];
```

Дочерняя сущность

```
  @ManyToOne(
    () => ParentEntity,
    (parent) => parent.сhildren,
    {
      onDelete: 'SET NULL',
      onUpdate: 'CASCADE'
    }
  )
  @JoinColumn({ name: 'parent_id', referencedColumnName: 'id' })
  parent: ParentEntity;
```

DTO Родителя

```
  @Field(() => [ChildDto], { nullable: true })
  children?: ChildDto[];
```

DTO Дочерней сущности

```
  @Field(() => ParentDto, { nullable: true })
  parent?: ParentDto;
```

Чтобы сбросить родителя из дочерней сущности, если родитель уже был задан, нужно прописать значение для родителя **null**. Если просто пропустить поле родителя, он не будет изменен.

Чтобы сбросить родителя для дочерних сущностей из сущности родителя, нужно указать массив **id** только тех дочерних сущностей, которые должны иметь этого родителя. Если нужно сбросить родителя вообще у всех дочерних сущностей, то нужно передать пустой массив или **null**. Если просто пропустить поле дочерних сущностей, родитель не будет изменен.

> Будьте осторожны! Если в дочерней сущности **onDelete** задан **CASCADE**, то при сбросе родителя из сущности родителя все связанные дочерние сущности будут удалены!

Обратите внимание, что в данном случае мы рекомендуем именовать поле объекта родительской сущности в единственном числе, а дочерней - во множественном.

[^ к оглавлению](#оглавление)

## Многие-ко-многим

Иногда бывают случаи, когда в каждой из таблицы каждая запись может иметь связи с несколькими записями из другой таблицы.

Например, дочерняя таблица представляет собой таблицу тегов. Каждой записи из родительской таблицы может быть присвоено несколько тегов. Однако при этом любой из этих тегов может быть присвоен нескольких записям.

> Обратите внимание, в отношениях многие к одному каждый тег может иметь связь только с одной записью из родительской таблицы.

| parent_table.id | child_table.id | child_table.parent_id |
| --------------- | -------------- | --------------------- |
| 0               | 0              | 0                     |
| 1               | 1              | 0                     |
|                 | 1              | 1                     |
| 2               | 2              | 0                     |
|                 | 2              | 1                     |
|                 | 2              | 2                     |

Конечно в простой реляционной базе таких записей быть не может из-за невозможности дублирования первичных ключей.

Поэтому связь многие-ко-многих создается через одну промежуточную таблицу, к которой родительская и дочерняя таблица имеет связь один-ко-многим.

parent_table

| id  |
| --- |
| 0   |
| 1   |
| 2   |

child_table

| id  |
| --- |
| 0   |
| 1   |
| 2   |

parent_by_child_table

| id  | child_id | parent_id |
| --- | -------- | --------- |
| 0   | 0        | 0         |
| 1   | 1        | 0         |
| 2   | 1        | 1         |
| 3   | 2        | 0         |
| 4   | 2        | 1         |
| 5   | 2        | 2         |

Родительская сущность

```
  @ManyToMany(
    () => ChildEntity,
    (сhild) => сhild.parents,
    {
      onDelete: 'CASCADE',
      onUpdate: 'CASCADE'
    }
  )
  сhildren: ChildEntity[];
```

Дочерняя сущность

```
  @ManyToMany(
    () => ParentEntity,
    (parent) => parent.children,
    {
      onDelete: 'CASCADE',
      onUpdate: 'CASCADE'
    }
  )
  @JoinTable({
    name: 'parent_by_child_table',
    joinColumn: { name: 'child_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'parent_id', referencedColumnName: 'id' }
  })
  parents: ParentEntity[];
```

DTO Родителя

```
  @Field(() => [ChildDto], { nullable: true })
  children?: ChildDto[];
```

DTO Дочерней сущности

```
  @Field(() => [ParentDto], { nullable: true })
  parents?: ParentDto[];
```

Обратите внимание, что в данном случае поля объекта родительской и дочерней сущностей мы рекомендуем именовать во множественном числе.

В отношениях многие-ко-многим при удалении родительской сущности дочерние сущности не удаляются ни при каких условиях. То же самое работает в обратную сторону.

[^ к оглавлению](#оглавление)

## Каскады

Kаскадные операции позволяют автоматически выполнять определенные действия со связанными сущностями:

- действия с дочерними записями при создании родительской,
- действия с дочерними записями при обновлении родительской,
- действия с дочерними записями при удалении родительской.

Каскадные связи на уровне приложения устанавливаются опцией **cascade**. Например:

```
  cascade: true
```

Или можно ограничить каскадирование только для определенных запросов. Например:

```
  cascade: ['insert']
```

Каскадирование лучше ставить в родительской сущности, потому что в таком случае из родительской сущности можно будет управлять дочерними сущностями а не наоборот.

Кроме того, каскадирование на уровне приложения разрешает создавать новые дочерние сущности и менять значения полей у существующих дочерних сущностей. Если вам не нужно такое поведение, вы можете отключить (или не создавать) каскадирование на уровне приложения, но оставить каскадные связи на уровне базы данных.

Вы можете задавать правила работы с внешними ключами на уровне связей в таблицах. Например:

```
  onDelete: 'CASCADE',
  onUpdate: 'CASCADE'
```

Если вы хотите запретить изменение связей из родительской сущности, вам нужно установить значение **restrict**:

```
  onDelete: 'RESTRICT',
  onUpdate: 'RESTRICT'
```

> Это для примера. А вообще значение **restrict** стоит по-умолчанию. Поэтому вы можете просто не указывать опции для каскадных операций.

Если вы хотите оставлять дочернюю запись при удалении родительской, вам нужно задать следующие настройки:

```
  onDelete: 'SET NULL'
```

> Обычно этих опций хватает, но если вам нужно более гибко управлять отношениями, вы можете использовать опции **eager** и **orphanedRowAction**. Подробнее с ними можно ознакомиться в официальной документации.

В приведенных выше примерах мы включаем каскады для добавления и обновления записей и разрешаем каскадное удаление. С точки зрения целостности данных при установлении каскадных отношений, одна запись не может существовать без другой.

Однако в сложных проектах может возникнуть ситуация, при которой разные сущности могут существовать независимо друг от друга и при этом выстраивать по нескольку отношений между собой. В таких случаях при удалении связанных сущностей нужно просто обрывать связь без удаления самих записей. То есть:

```
  onDelete: 'SET NULL'
```

[^ к оглавлению](#оглавление)

## Пример построения

Рассмотрим на примере постов.

Посты по-умолчанию являются базовой единицей. Каждый пост привязан к какому-либо автору, поэтому посты связаны с пользователями отношением многие-к-одному.

Также посты могут относится к какой-либо категории, предполагается, что только к одной. Поэтому посты связаны с категориями тоже отношением многие-к-одному.

А вот тегов посты могут иметь несколько. И посты связаны с тегами отношением многие-ко-многим.

Для такой связи предусмотрено создание отдельной таблицы **posts_by_tags**.

Любые подобные отношения предполагают взаимное изменение и удаление. Например, пост может поменять категорию, а при удалении категории, удалятся все посты, которые входят в нее.

[^ к оглавлению](#оглавление)

# Модель данных

## Защита модели данных

Сервер предлагает четыре уровня защиты данных:

- common - общая,
- protected - защищенная,
- private - частная,
- closed - закрытый.

Общая защита, **common**, представляет собой открытость всех данных и операций по ним. Это означает, что любой пользователь может читать, создавать, изменять и удалять любые записи.

Второй уровень защиты, **protected**, позволяет всем пользователям читать любые записи, но изменять и удалять только свои. При создании новой записи, она автоматически привязывается к учетной записи пользователя.

Третий уровень защиты, **private**, позволяет пользователям читать, изменять и удалять только свои записи. При создании новой записи, она также автоматически привязывается к учетной записи пользователя.

Самый высокий уровень защиты, **closed**, разрешает пользователям читать все записи, но запрещает создавать, изменять и удалять их. Исключение составляют только суперпользователи, и те пользователи, у которых есть соответствующие права.

> Если вам нужны более гибкие ограничения, их можно задать на уровне прав и ролей.

> На данный момент механизм прав и ролей реализован не полностью!

[^ к оглавлению](#оглавление)

## Описание модели данных

Модель данных в **TypeORM** автоматически формирует базу данных с необходимыми полями и связями. Также на ее основе автоматически генерируется схема GraphQL. Такие модели представлены файлами с расширением **.entity.ts**.

Также мы использем DTO - классы описания данных, которые используются для типизации передаваемых данных к сервисам. Такие модели данных представлены файлами с расширением **.dto.ts**.

Все модели данных наследуют базовый класс, который содержит поля:

- id
- createdAt
- updatedAt

Для TypeORM это:

    src/common/entity/common.entity.ts

Для DTO это:

    src/common/entity/common.dto.ts

Есть защищенные модели данных, которые требуют передачи id учетной записи. Они наследуются от базовой модели, но имеют дополнительное поле:

- auth

Для TypeORM это:

    src/common/entity/protected.entity.ts
    src/common/entity/private.entity.ts
    src/common/entity/closed.entity.ts

Для DTO это:

    src/common/entity/protected.dto.ts
    src/common/entity/private.dto.ts
    src/common/entity/closed.dto.ts

По-умолчанию, защищенные модели данных имеют к auth отношения многие-к-одному. Если вам нужно изменить отношения на один-к-одному, вы должны наследовать модель от одной из следующих сущностей:

    src/common/entity/protected_one.entity.ts
    src/common/entity/private_one.entity.ts

[^ к оглавлению](#оглавление)

## Настройка модели данных

Посмотрим, как реализована защищенная модель **posts**.

Контроллер, резолвер, DTO и сущность наследуются от базовых классов уровня **protected**. Это означает, что любой пользователь имеет доступ к чтению данных, но создание, изменение и удаление разрешены только владельцу.

Здесь между сущностью **auth** и моделью данных **posts** автоматически создаются отношения один-ко-многим.

Теперь посмотрим, как реализована защищенная модель **users**.

Контроллер, резолвер, DTO и сущность наследуются от базовых классов уровня **private**. Это означает, что чтение, создание, изменение и удаление разрешены только владельцу.

Кроме того, сущность UsersEntity наследует класс PrivateOneEntity. Он также создает связь между сущностью **auth** и моделью данных **users**, но с отношением один-к-одному.

> Не забываем, что отношения нужно устанавливать также и с другой стороны, т.е. со стороны сущности **auth**.

Теперь предположим, что нам нужно переключить отношения модели **posts** с **auth** на **users**.

Во-первых, для этого мы должны получать данные **users** при авторизации. Для этого в стратегии авторизации **AuthStrategy** (src/auth/auth.strategy.ts), в методе **validate**, при чтении данных авторизации, мы должны добавить отношения к таблице **users**:

    const auth = await this.authService.findOne(id, [{ name: 'users' }]);

Далее, в защищенных методах мы должны обращаться к полю **users.id** вместо **auth.id**. Для этого мы предусмотрели в контроллерах, резолверах и сервисных методах поле **authTable**.

По-умолчанию оно пустое, и в этом случае, **id** будет браться из **auth**. Но если его задать как **users**, то поле **id** будет браться из **auth.users.id**.

Например, в файле **src/posts/posts.controller.ts** поменять:

```
export class PostsController extends ProtectedController(
  'Посты',
  PostsEntity,
  PostsDto,
  'users',
)...
```

И в файле **src/posts/posts.resolver.ts** поменять:

```
export class PostsResolver extends ProtectedResolver(
  'posts',
  PostsEntity,
  PostsDto,
  'users',
)...
```

Также нужно не забыть отвязать сущность **posts** от **auth**. Для этого в файле **src/posts/posts.entity.ts** поменять:

```
export class PostsEntity extends CommonEntity {
    @ManyToOne(() => UsersEntity)
    @JoinColumn({ name: 'user_id', referencedColumnName: 'id' })
    users: UsersEntity;
    ...
```

По аналогии внести изменения в файл **src/posts/posts.dto.ts**:

```
export class PostsDto extends CommonDto {
    @Field(() => UsersDto, { nullable: true })
    users?: UsersDto;
    ...
```

[^ к оглавлению](#оглавление)

## Генерация модели данных

Если вы используете существующую базу данных и хотите сгенерировать модель на ее основе, вы можете воспользоваться подключенной библиотекой **typeorm-model-generator**.

Вызов:

```
yarn|npm run typeorm-model-generator -h {DB_HOST} -d {DB_NAME} -u {DB_USERNAME} -x {DB_PASSWORD} -e {mysql|postgres} -o ./src/typeorm/
```

Пример вызова:

```
yarn typeorm-model-generator -h localhost -d mydatabase -u root -x 1234 -e mysql -o ./src/typeorm/
```

[^ к оглавлению](#оглавление)

## Защита полей

Можно защитить отдельные поля, сделав их приватными.

Для этого в сущности нужно указать декоратор **PrivateColumn**.

```
@PrivateColumn
@Column(...)
columnName: someType;
```

В декораторе **Auth** задать параметр **noBlock** для контроллера и **gqlNoBlock** для резолвера. Этот параметр разрешает не блокировать вывод.

```
@Auth('noBlock')
@Get('find')
...
```

Теперь защищенные колонки будут недоступны для вывода через неавторизованный запрос. При этом сам запрос не будет блокироваться, если нет авторизации.

[^ к оглавлению](#оглавление)

# Контроллеры и резолверы

Контроллеры используются для запуска методов RestAPI. Контроллеры представлены файлами с расширением **.controller.ts**.

Для GraphQL вместо контроллеров используются резолверы. Они представлены файлами с расширением **.resolver.ts**.

Контроллеры и резолверы мы рекомендуем использовать в качестве обертки, а сам функционал реализовывать в сервисах.

[^ к оглавлению](#оглавление)

## Аргументы запросов

Мы сделали так, что контроллеры и резолверы используются максимально похоже.

Резолверы принимают аргументы через переменные GraphQL запроса, а контроллеры - через тело запроса. В обоих случаях аргументы имеют формат **JSON**.

Например, для условного запроса **findOne**, требуется аргумент **id**. Для контроллера и резолвера он будет передан одинаково:

    {
        "id": 1
    }

Для получения данных из тела запроса, есть встроенный декоратор **@Body**. Но если вы используете библиотеку **axios**, вы не сможете передать данные в запрос **get**.

Мы сделали декоратор **@Data**, который объединяет данные из тела **body** и параметров **query** запроса. Декоратор имеет один аргумент, который может вытягивать из запроса только определенные данные.

Пример для контроллеров:

    ...(@Data('id') id: number) {...}

В общем, декоратор **@Data** заменяет собой **@Body**.

> Декоратор не имеет смысл использовать в резолверах.

[^ к оглавлению](#оглавление)

## Методы запросов

В реализации контроллеров мы используем стандарт RESTful API.

Так выглядит пример запроса:

```
api/resource/endpoint
```

- **api** является точкой входа,
- **resource** указывает на запрашиваемый ресурс,
- **endpoint** может содержать сложный путь, даже с некоторыми параметрами.

Параметры запроса передаются в виде JSON.

Методы запросов назначаются декораторами. Например:

```
import { ... Get, ... } from '@nestjs/common';
...

  @Get('find')
  async postsFind() {
    ...
```

Доступные методы HTTP-запросов:

- GET, получает полные данные (тело и заголовки),
- HEAD, получает только заголовки (служебную информацию),
- POST, отправляет данные на сервер,
- PUT, отправляет запрос на создание нового ресурса на сервере, либо на замену существующего,
- PATCH, отправляет запрос на изменение фрагмента ресурса,
- DELETE, отправляет запрос на удаление ресурса,
- CONNECT, устанавливает постоянную двунаправленную связь (туннель) с сервером,
- OPTIONS, отправляет запрос на получение параметров соединения,
- TRACE, отправляет запрос, и получает его обратно для сравнения (например, какую информацию промежуточные серверы добавляют или изменяют в запросе).

Методы GET, HEAD и OPTIONS считаются безопасными, потому что по установленному стандарту вызов этих методов состояния ресурса (данных на сервере) не изменяет. Остальные - нет. Поэтому сервер должен обязательно их проверять.

По-умолчанию методы GET и HEAD кэшируются, остальные - нет. Поэтому при использовании метода POST можно быть уверенным, что запрос выполнится. В случае с GET Вы можете получить ответ из кэша, так что запрос напрямую до сервера может и не дойти.

В использовании методов могут возникнуть проблемы, связанные с тем, что библиотеки фронтенда могут работать не со всеми методами. В этом случае мы предлагаем использовать в контроллерах только два методов: GET и POST.

[^ к оглавлению](#оглавление)

## Пути запросов

Глобальный префикс пути настраивается в файле **.env** в переменной окружения **PREFIX**.

Если вы используете для вашего API отдельный домен, вы можете оставить пустой путь:

```
PREFIX=
```

Вы можете задать глобальный префикс, например **api** и тогда бэк будет доступен по адресу **http://localhost/api**

Если вы используете разные версии API, то вы можете добавить к пути номер версии. Например, так:

```
PREFIX=/api/v3
```

Пути к методам API задаются в контроллерах:

```
@Controller('posts')
export class PostsController {
  ...

  @Get('find')
  async postsFind() {
    ...
```

Данный метод будет вызван по адресу запроса

    /posts/find

Если вы использовали глобальный префикс, например **api**, то адрес будет таким:

    /api/posts/find

[^ к оглавлению](#оглавление)

# Сервисы

Сервисы представляют собой классы, которые реализуют код сервисных функций. Они представлены файлами с расширением **.service.ts**.

Сервисы реализуют методы, которые перечислены в соответствующем разделе.

Однако, могут возникнуть ситуации, когда некоторые методы окажутся для вас избыточными. В таком случае, вы можете просто удалить их из контроллера и резолвера.

[^ к оглавлению](#оглавление)

## Объединение сервисов

Чтобы объединять сервисы одной сущности, в файле **.module.ts** источника запровайдите их таким образом:

    @Module({
        ...
        providers: [PostsService, PostsCustomService],
        ...
    })

Возможно, вам также понадобится объединять сервисы разных сущностей.

Для этого в файле **.module.ts** источника импортируйте модули источника целиком:

    @Module({
        ...
        imports: [
            ...
            forwardRef(() => TestsModule),
        ],
        ...
    })

> Не забудьте импортировать **forwardRef** из библиотеки **@nestjs/common**!

После в сервисе получателя, в конструкторе, объявите сервисы источника таким образом:

    constructor(
        @InjectRepository...
        private readonly testsService: TestsService,
    ) {}

Важно следить за тем, чтобы не получилось перекрестного объединения, когда источник попадает в получателя, но получатель при этом является источником для своего источника.

[^ к оглавлению](#оглавление)

# Методы

Мы предлагаем реализацию базовых методов для каждой сущности, что покрывает 90% всех потребностей.

Методы условно разбиты на три группы:

- стандартные методы получения данных
- расширенные методы получения данных, такие как поиск, сортировка и группировка
- методы изменения данных

Эти методы:

- find - получить все записи или записи по заданным условиям,
- findone - получить одну запись по id,
- findmany - получить несколько записей по списку id,
- first - получить одну запись по заданным условиям,
- self - найти записи, принадлежащие учетной записи пользователя (только для **private**),
- create - создать новую запись,
- update - обновить запись,
- remove - удалить запись.

Важно учитывать, что в сервисах и резолверах эти методы имеют впереди название сущности и пишутся в стиле camelCase. Например:

    postsFind

В контроллерах эти методы записываются в стиле flatcase. Название сущности задается в имени контроллера. Например:

    find
    /posts/find

Мы используем такую нотацию потому что базовые методы короткие. Если вы используете свои методы с длинными названиями, рекомедуем использовать нотации kebab-case или snake_case. Например:

    /posts/get-by-auth-id
    /posts/get_by_auth_id

Далее следует подробное описание базовых методов.

[^ к оглавлению](#оглавление)

## Базовые методы

### Метод find

Получить все записи по условиям

RestAPI:

    GET .../find

GraphQL:

    query ...Find($where: JSONObject, $order: JSONObject) {
        result: ...Find(where: $where, order: $order) {
            ...
        }
    }

Параметры:

    {
        "where": {
            ...
        },
    	"search": {
    	    "fields": ["first", "second", "sub.some"],
    	    "terms": ["search", "words"],
            "method": "and"
        },
        "order": {
            "id": "ASC"
        }
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    ...
                },
                ...
            ]
        }
    }

В ответ попадает массив записей с запрошенными полями.

Чтобы получить абсолютно все записи, используйте пустое поле where.

[^ к оглавлению](#оглавление)

### Метод findOne

Получить одну запись по id

RestAPI:

    GET .../find/:id

GraphQL:

    query ...FindOne($id: Float!) {
        result: ...FindOne(id: $id) {
            ...
        }
    }

Параметры:

    {
        "id": ...
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В ответ попадает одна запись с запрошенными полями.

[^ к оглавлению](#оглавление)

### Метод first

Получить одну запись по заданным условиям

RestAPI:

    GET .../first

GraphQL:

    query ...First($where: JSONObject) {
        result: ...First(where: $where) {
            ...
        }
    }

Параметры:

    {
        "where": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В ответ попадает одна, самая первая, запись с запрошенными полями.

[^ к оглавлению](#оглавление)

### Метод findMany

Получить несколько записей по списку id

RestAPI:

    GET .../many/:ids

GraphQL:

    query ...Many($ids: [Float!]!) {
        result: ...Many(ids: $ids) {
            ...
        }
    }

Параметры:

    {
        "ids": [...]
    }

Ответ:

    {
        "data": {
            "result": [
                {
                    ...
                },
                ...
            ]
        }
    }

В ответ попадает массив записей с запрошенными полями.

[^ к оглавлению](#оглавление)

### Метод self

Получить записи, принадлежащие учетной записи пользователя

RestAPI:

    GET .../self

GraphQL:

    query ...Self($where: JSONObject) {
        result: ...Self(where: $where) {
            ...
        }
    }

Параметры:

    {
        "where": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

> Этот метод существует только в частных (**private**) контроллерах и резолверах.

[^ к оглавлению](#оглавление)

### Метод create

Создать новую запись

RestAPI:

    POST create

GraphQL:

    mutation create($create: ...Dto!) {
        result: create(create: $create) {
            ...
        }
    }

Параметры:

    {
        "create": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В результат попадают запрошенные поля.

[^ к оглавлению](#оглавление)

### Метод update

Обновить запись

RestAPI:

    PATCH update/:id

GraphQL:

    mutation update($update: ...Dto!) {
        result: update(update: $update) {
            ...
        }
    }

Параметры:

    {
        "update": {
            ...
        }
    }

Ответ:

    {
        "data": {
            "result": {
                ...
            }
        }
    }

В результат попадают запрошенные поля.

[^ к оглавлению](#оглавление)

### Метод remove

Удалить запись

RestAPI:

    DELETE remove/:id

GraphQL:

    mutation remove($id: Float!) {
        result: remove(id: $id)
    }

Параметры:

    {
        "id": ...
    }

Ответ:

    {
        "data": {
            "result": ...
        }
    }

В результат попадает число удаленных записей. Если ни одна запись не удалена, в результате будет **0**.

[^ к оглавлению](#оглавление)

### Методы сортировки

Для сортировки записей должно использоваться числовое поле. В него будут записаны цифры, по которым в дальнейшем это поле можно выводить.

Нельзя использовать поле **id**, потому что при пересортировке могут измениться связанные поля.

Рекомендуется называть это поле **position**, потому что такое название не задействует ключевые слова и операторы языка **sql**.

Методы сортировки:

- positionSort - сортировка по условиям,
- positionMove - перемещение поля на новое место.

Каждый метод возвращает **true** в случае успеха или ошибку в случае неудачи.

Предположим, у нас есть записи от 0 до 10. Будем выполнять с ними разные действия, а результат сортировать по позициям.

Выполним сортировку по идентификатору в обратном порядке:

RestAPI:

    POST position/sort

Параметры:

    {
        "field": "position",
        "order": {
            "id": "desc"
        }
    }

Результат:

| id  | position |
| --- | -------- |
| 10  | 1        |
| 9   | 2        |
| 8   | 3        |
| 7   | 4        |
| 6   | 5        |
| 5   | 6        |
| 4   | 7        |
| 3   | 8        |
| 2   | 9        |
| 1   | 10       |
| 0   | 11       |

Мы удалили запись с номером 3 и снова выполняем пересортировку.

Результат:

| id  | position |
| --- | -------- |
| 10  | 1        |
| 9   | 2        |
| 8   | 3        |
| 7   | 4        |
| 6   | 5        |
| 5   | 6        |
| 4   | 7        |
| 2   | 8        |
| 1   | 9        |
| 0   | 10       |

Переместим запись **id** 5 на позицию 3.

Ее текущая позиция 6. Это значит, что будут обновлены записи с позициями с 3 по 6.

RestAPI:

    POST position/move/5

Параметры:

    {
        "field": "position",
        "position": 3
    }

Результат:

| id  | position |
| --- | -------- |
| 10  | 1        |
| 9   | 2        |
| 5   | 3        |
| 8   | 4        |
| 7   | 5        |
| 6   | 6        |
| 4   | 7        |
| 2   | 8        |
| 1   | 9        |
| 0   | 10       |

Переместим запись с **id** 5 на позицию 8.

Ее текущая позиция 3. Это значит, что будут обновлены записи с позициями с 3 по 8.

RestAPI:

    POST position/move/5

Параметры:

    {
        "field": "position",
        "position": 8
    }

Результат:

| id  | position |
| --- | -------- |
| 10  | 1        |
| 9   | 2        |
| 8   | 3        |
| 7   | 4        |
| 6   | 5        |
| 4   | 6        |
| 2   | 7        |
| 5   | 8        |
| 1   | 9        |
| 0   | 10       |

[^ к оглавлению](#оглавление)

## Опции

Есть методы, которые поддерживают опции.

К опциям относятся:

- order - сортировка по полю,
- desc - сортировка в обратном порядке,
- skip - пропустить какое-то количество записей,
- limit - получить только указанное количество записей,
- page - номер страницы с 0,
- group - поле, по которому записи будут сгруппированы,
- type - тип группировки.

Если не указывать опции, то эти методы будут выводить все найденные записи в **list** с подсчетом из числа в **count**.

Опции отношений поддерживают все методы, кроме метода **remove**.

[^ к оглавлению](#оглавление)

### Опции отношений

При проектировании системы неизбежно появляется большое число отношений. Но слишком большое число отношений приводит к тому, что из базы подтягивается множество лишних полей. Такие запросы потребляют много памяти, забивают канал передачи данных и вызывают большие задержки.

Чтобы этого избежать, в **каждом** запросе вы можете указать только нужные в данный момент связи.

Связи передаются в аргументе **relations** и задаются массивом объектов **RelationsDto**:

    "relations": [
        {
            "name": "category",
            "order": "id",
            "desc": false
        }
        {
            "name": "tags",
            "order": "id",
            "desc": false
        }
        ...
    ]

Параметр **name** задает имя объекта (таблицы), который будет использован для связывания.

Параметры **order** и **desc** являются необязательными и служат для сортировки связанных объектов в переданном ответе. По-умолчанию, сортировка идет по полю **id** в порядке возрастания.

Такие связи, например, для постов позволяют получить категорию поста и все его теги в виде вложенного объекта и массива объектов соответственно.

Аргумент **relations** всегда стоит последним в запросе и является необязательным.

Например:

    postsFind()
    postsFind(relations)

Вы можете даже использовать двухуровневые связи типа **post.category**, но только если вложенные сущности не дублируют исходную сущность.

Многоуровневые связи типа **post.category.posts** создавать нельзя из-за возникновения перекрестного объединения сущностей.

> Теперь метод **update** можно делать с использованием отношений, однако для отношений один-ко-многим и многие-ко-многим требуется задавать **id** полей, которые будут обновляться.

[^ к оглавлению](#оглавление)

### Опции фильтрации

Если вы задаете поле **limit**, то автоматически включается поддержка страниц **page**. Например, вы можете указать лимит 10 записей, и по-умолчанию вам будут выданы записи с 1 по 10.

Но если вы укажете страницу 1, то вам будут выданы записи с 11 по 20.

> Страницы, как и массивы, начинаются с 0.

Также в ответе вам будет выдано общее число страниц **pages**.

Независимо от опций фильтрации, в ответе вам будет выдано общее число записей **count**. На данные этого счетчика не влияют **skip**, **limit** и **page**.

[^ к оглавлению](#оглавление)

### Опции группировки

Группировка - еще одна интересная вещь. Вы можете сгруппировать данные по какому-либо полю. Причем в указании поля поддерживаются отношения. Например **title** и **category.title**.

В случае с имеющимися отношениями, такая группировка может быть необоснована. Например, вы можете получить записи по категориям, запросив категории со вложенным массивом записей.

Однако, если вы хотите группировать записи по другому признаку, например по какому-либо полю, например, по дате создания, такая группировка может помочь.

Также группировка может помочь избежать создания перекрестных отношений.

В типе группировки вы можете указать следующие значения:

- string - строка,
- number - число,
- boolean - булев тип, true/false,
- другое - дата.

Если указать любое другое значение, то оно будет распознано как формат даты. Например **YYYY.MM.DD**.

> Для преобразования дат используется библиотека **moment.js**.

Указывая тип, значение поля будет принудительно приведено к этому типу.

Если значение не указывать, то тип останется таким же, как в оригинальном поле.

В случае применения группировки, в ответе будет массив из нескольких объектов, у каждого из которых в поле **group** будет значение поля группировки.

Например, ответ без группировки:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "group": null,
                    "list": [
                        { ... },
                        ...
                    ]
                }
            ]
        }
    }

Например, ответ с группировкой:

    {
        "data": {
            "result": [
                {
                    "count": ...,
                    "group": "...",
                    "list": [
                        { ... },
                        ...
                    ]
                },
                {
                    "count": ...,
                    "group": "...",
                    "list": [
                        { ... },
                        ...
                    ]
                },
                ...
            ]
        }
    }

В ответе вам также будет выдано число записей **count**, но для каждой группы отдельно.

Вы можете использовать вместе с группировкой и другие опции, но будьте осторожны, т.к. результат может оказаться не тем, который вам нужен.

Например, в группы не попадут записи по лимитам, а сортировка групп будет происходить на основе сортировки записей. Если сортировку не указать принудительно, то сортировка будет идти по тому же полю, что и группировка.

> Для сортировки групп в обратном порядке, рекомендуем указывать только опцию **desc: true**.

[^ к оглавлению](#оглавление)

### Опции технически

Поля опций заданы в файле **src/common/dto/options.dto.ts**.

Сервисные функции, которые обрабатывают эти поля, заданы в файле **src/common/service/options.service.ts**.

Чтобы не вызывать каждую функцию отдельно, мы включили сервисную функцию **optionsService**, которая, собственно подготавливает объект опций.

Кроме этого, она также вызывает репозиторий **typeorm** на выполнение, поэтому она требует передать ей репозиторий в качестве одного из аргументов.

Другими словами, **optionsService** подготавливает запрос, выполняет его и возвращает результат.

[^ к оглавлению](#оглавление)

## Наследование методов

Большинство сущностей наследуют базовые классы.

Такой подход позволяет упростить создание модуля и избежать повторения бесчисленного количества методов.

Мы предлагаем наследовать базовые сервисные функции, базовый контроллер и базовый резолвер.

[^ к оглавлению](#оглавление)

### Наследование контроллера

Базовый контроллер находится по пути

    /common/controller/common.controller.ts

Код наследования в вашем контроллере:

```
@Controller('posts')
export class PostsController extends CommonController<
  PostsService,
  PostsEntity,
  PostsDto,
> {
  constructor(
    protected readonly service: PostsService,
  ) {
    super();
  }
}
```

Есть защищенный контроллер, который требует авторизации пользователя и id учетной записи.

Он наследуется от базового контроллера и защищает методы:

- create,
- update,
- remove.

Защищенные контроллеры находятся по пути

    /common/controller/protected.controller.ts
    /common/controller/private.controller.ts
    /common/controller/closed.controller.ts

Код наследования в вашем контроллере:

```
@Controller('posts')
export class PostsController extends ProtectedController...
```

```
@Controller('posts')
export class PostsController extends PrivateController...
```

```
@Controller('posts')
export class PostsController extends ClosedController...
```

[^ к оглавлению](#оглавление)

### Наследование резолвера

Базовый резолвер находится по пути

    /common/resolver/common.resolver.ts

Код наследования в вашем контроллере:

```
@Resolver(PostsEntity)
export class PostsResolver extends CommonResolver(
  'posts',
  PostsEntity,
  PostsDto
)<
  PostsService,
  PostsEntity,
  PostsDto
> {
  constructor(
    readonly service: PostsService,
  ) {
    super();
  }
}
```

Есть защищенный резолвер, который требует авторизации пользователя и id учетной записи.

Он наследуется от базового резолвера и защищает методы:

- create,
- update,
- remove.

Защищенные резолверы находятся по пути

    /common/resolver/protected.resolver.ts
    /common/resolver/private.resolver.ts
    /common/resolver/closed.resolver.ts

Код наследования в вашем контроллере:

```
@Resolver(PostsEntity)
export class PostsResolver extends ProtectedResolver...
```

```
@Resolver(PostsEntity)
export class PostsResolver extends PrivateResolver...
```

```
@Resolver(PostsEntity)
export class PostsResolver extends ClosedResolver...
```

[^ к оглавлению](#оглавление)

### Наследование сервисов

Базовые сервисы находятся по пути

    /common/service/common.service.ts

Код наследования в ваших сервисах:

```
@Injectable()
export class PostsService extends CommonService<
  PostsEntity,
  PostsDto
> {
  constructor(
    @InjectRepository(PostsEntity)
    protected readonly repository: Repository<PostsEntity>,
  ) {
    super();
  }
}
```

Если вам нужно расширить какую-либо базовую сервисную функцию, вы можете просто написать ее заново.

Если вам нужно использовать внутри код базовой функции, вы можете сделать это через вызов super.

Например:

```
  constructor(
    @InjectRepository(PostsEntity)
    protected readonly repository: Repository<PostsEntity>,
    protected readonly categoriesService: CategoriesService,
    protected readonly tagsService: TagsService,
  ) {
    super();
  }

  async create(
    postsDto: PostsDto,
    relations: Array<RelationsDto> = undefined,
  ): Promise<PostsEntity> {
    const { categoryId } = postsDto;
    if (categoryId) {
      const category = await this.categoriesService.findOne(
        categoryId,
      );
      postsDto.category = category;
    }
    delete postsDto.categoryId;
    const { tagsList } = postsDto;
    if (tagsList && tagsList.length) {
      const tags = await this.tagsService.findMany(tagsList);
      postsDto.tags = (postsDto.tags || []).concat(tags);
    }
    delete postsDto.tagsList;
    return await super.create(postsDto, relations);
  }
```

Для сервисов отсутствует понятие защищенности, потому что на этом уровне представления системе не должно быть известно о политике защиты.

Сервисы имеют условия фильтрации по id учетной записи. Но условия проверки ложатся на контроллеры, резолверы и внешние вызовы сервисных методов.

[^ к оглавлению](#оглавление)

# Работа с файлами

На текущий момент загрузка файлов возможна только через контроллер. Резолверы не поддерживаются.

Контроллер **files** реализует только один метод **upload**, который поддерживает query-параметры **options**:

- options.convert - true/false, разрешает конвертацию изображений в формат **webp**,
- options.folder - строка, этот параметр нужен для того, чтобы загружать файл во вложенные каталоги,
- options.rename - true/false, разрешает переименовать файл в **uuid**,
- options.replace - true/false, разрешает перезаписать файл, если такой уже есть на сервере,
- options.resize - true/false, разрешает уменьшать изображение, если оно превышает установленные допустимые размеры по ширине и высоте.

Изначальный каталог для загрузки файлов задается в **.env** файле, в параметре **UPLOADS_PATH**.

Метод позволяет загружать несколько файлов одновременно, устанавливать максимально допустимый размер и разрешенные типы файлов.

Кроме того, метод конвертирует изображения в формат **webp**, ужимая большие до заданных пределов с сохранением соотношения сторон.

> для работы с изображениями используется библиотека **sharp**.

В качестве результата выдается массив с расширенной информацией о каждом файле:

- url - ссылка на файл,
- originalname - имя файла,
- mimetype - mime-тип,
- size - размер в байтах.

Для работы с файлами, вы можете построить свои контроллеры, используя существующие сервисные функции.

[^ к оглавлению](#оглавление)

## filesSave

Сохраняет файлы в заданный вложенный каталог.

В случае ошибки при записи файла, выбрасывает исключение.

Принимает аргументы:

- массив экземпляров интерфейса,
- вложенный каталог (строка), необязательный.

Возвращает массив экземпляров интерфейса.

[^ к оглавлению](#оглавление)

## filesRename

Дает файлу новое имя в виде случайно сгенерированного набора символов по стандарту **uuid** версии 4.

Принимает аргументы:

- экземпляр интерфейса,
- расширение (строка), необязательный.

Возвращает экземпляр интерфейса.

[^ к оглавлению](#оглавление)

## filesMaxSize

Вычисляет, соответствует ли файл заданному размеру.

Если размер не указан или равен 0, то файл всегда будет соответствовать.

Принимает аргументы:

- экземпляр интерфейса,
- максимальный размер (число), необязательный.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesAllowTypes

Вычисляет, соответствует ли файл заданному типу.

Тип может быть указан как один из mime-типов, либо его часть, либо массив.

Например:

    'jpeg'
    'image/jpeg'
    'image/*'
    'image'
    ['jpeg', 'png', 'webp']
    ['audio', 'image', 'video']

Если тип не указан, то файл всегда будет соответствовать.

Принимает аргументы:

- экземпляр интерфейса,
- типы (строка или массив строк), необязательный.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesIsImage

Вычисляет, является ли файл изображением.

Работает по mime-типу файла.

Принимает аргументы:

- экземпляр интерфейса.

Возвращает true/false.

[^ к оглавлению](#оглавление)

## filesImageMetadata

Возвращает метаданные изображения.

Работает через библиотеку **sharp**.

Принимает аргументы:

- буфер.

Возвращает метаданные.

[^ к оглавлению](#оглавление)

## filesImageResize

Меняет размер изображения, ширину и высоту.

В качестве опций можно указать объект:

    {
        width,
        height,
        fit,
        position,
        background,
        kernel
    }

Работает через библиотеку **sharp**.

Подробнее обо всех параметрах можно узнать в документации на библиотеку.

Принимает аргументы:

- буфер,
- опции.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## filesImageOversize

Меняет размер изображения если оно превышает заданные ширину или высоту.

Сохраняет соотношение сторон.

В качестве опций можно указать объект:

    {
        width,
        height
    }

Работает через функцию **filesImageResize**.

Принимает аргументы:

- буфер,
- опции.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## convertToWebp

Конвертирует изображение в формат **webp**.

Работает через библиотеку **sharp**.

Принимает аргументы:

- буфер.

Возвращает буфер.

[^ к оглавлению](#оглавление)

## filesImageConvert

Конвертирует все изображения, кроме **svg**, в формат **webp**.

Работает через функцию **convertToWebp**.

Принимает аргументы:

- буфер.

Возвращает экземпляр интерфейса.

[^ к оглавлению](#оглавление)

## Интерфейс файла

Вся работа с файлами ведется через интерфейс, который содержит следующие поля:

- buffer - буфер с содержимым файла, необязательное,
- originalname - имя файла,
- mimetype - mime-тип файла,
- url - ссылка на файл, необязательное,
- size - размер в байтах, необязательное,
- width - ширина, только для изображений, необязательное,
- height - высота, только для изображений, необязательное.

Интерфейс создается через конструктор класса, который принимает файл в формате **Express.Multer.File** или экземпляр интерфейса.

[^ к оглавлению](#оглавление)

# Работа с почтой

Для работы с почтой мы используем средства **Nest.js**, которые по-сути являются надстройкой над библиотекой **Nodemailer**.

Пока что мы реализовали только отправку почты. Но в дальнейшем планируем расширить функционал до того, чтобы можно было реализовать полнофункциональный почтовый веб-интерфейс.

Базовые настройки соединения с почтым сервером задаются в переменных окружения, в секции с параметрами **SMTP**.

[^ к оглавлению](#оглавление)

## mailSend

Отправляет письмо.

Принимает аргументы:

- объект с опциями,
- массив файлов.

Возвращает результат отправки.

Объект опций **options** задан классом **MailDto** и имеет следующие поля:

- from - отправитель (пока не поддерживается), строка, проферка на соответствие формату email, необязательное,
- to - получатель, строка, проферка на соответствие формату email, обязательное,
- subject - тема письма, строка, необязательное,
- text - тест письма в формате **plain/text**, строка, необязательное,
- html - тест письма в формате **html**, строка, необязательное.

Как видите, все поля, за исключением **to** являются необязательными, а значит, их можно пропустить. Однако мы рекомендуем по-возможности заполнять все поля.

Поля **text** и **html** повторяют друг друга. На самом деле рекомендуется использовать только поле **html**, но **text** также может быть заполнен и отправлен в качестве поддержки старого формата.

Для отправки файлов используется второй аргумент **files**, который представляет собой массив объектов типа **FilesInterface**. Подробнее о нем можно посмотреть в разделе **Интерфейс файла**.

Однако на выходе мы уже получаем массив объектов другого типа - **mailAttachmentsInterface**. Он содержит следующие поля:

- filename - имя файла,
- content - строка, содержащая содержимое буфера файла, обычно кодированное в формат **base64**,
- encoding - строка, формат кодировки, обычно используют **base64**,
- contentType - mime-тип файла.

Содержимое этих полей можно взять из **FilesInterface**, но поле **content** скорее всего придется преобразовывать из буфера.

За отправку файлов отвечает контроллер **mail/send**. Данные отправляются методом **POST**.

Для отправки опций используйте поля **options[...]**. Например:

    options[to] = mail@site.ru
    options[subject] = Тема сообщения
    options[html] = <html><body><p>Текст сообщения</p></body></html>

Для отправки файлов используйте поля **file[]**. Например:

    file[] = file1.jpg
    file[] = file2.jpg

Ответ на успешно доставленное сообщение выглядит так:

    {
        "accepted": [
            "...to..."
        ],
        "rejected": [],
        "ehlo": [ ... ],
        "envelopeTime": ...,
        "messageTime": ...,
        "messageSize": ...,
        "response": "250 2.0.0 Ok: queued as CEBF34018D",
        "envelope": {
            "from": "...from...",
            "to": [
                "...to..."
            ]
        },
        "messageId": "<...>"
    }

[^ к оглавлению](#оглавление)

# Работа с базой данных

Для работы с базой данных мы используем библиотеку **TypeORM**.

Она позволяет синхронизировать изменения в БД, а также гибко управлять миграциями.

Возможно, в режиме разработки вам это не понадобится, но это станет необходимым при синхронизации изменений в локальной и **production** базах данных, а также при выключенной автоматической синхронизации в **.env** файле, в параметре **DB_SYNCHRONIZE**.

Для всего процесса миграции мы задали скрипты, которые еще больше автоматизируют весь процесс.

В начале работы вам наверняка потребуется сделать первую миграцию. Для этого используйте:

```shell script
npm run migration:fake
```

Далее, чтобы создать миграцию, выполните:

```shell script
npm run migration:auto
```

Запустить ее вы можете так:

```shell script
npm run migration:run
```

Откатить миграцию вы можете так:

```shell script
npm run migration:revert
```

Помните, что вам также необходимо, чтобы миграции были записаны в базе данных. Поэтому содержимое каталога **src/typeorm/migrations** и таблицу **migrations_typeorm** тоже можно синхронизировать.

Кстати, название таблицы можно задать в файле **src/config/db.config.ts**, в параметре **migrationsTableName**.

[^ к оглавлению](#оглавление)

# Шифрование

Шифрование происходит по алгоритму **AES-GCM**. В качестве соли берется значение переменной окружения **AES_SECRET**.

## encrypt

Для шифрования используется метод **encrypt** сервиса **crypt.service**.

    const data = await encrypt(...);

В качестве аргумента нужно передать строку, которую нужно зашифровать.

На выходе будет отдан объект, содержащий зашифрованную строку и вектор инициализации.

## decrypt

Для дешифрования используется метод **decrypt** сервиса **crypt.service**.

    const decrypted = await decrypt(data.encrypted, data.iv);

В первом аргументе нужно передать зашифрованную строку. Во втором аргументе нужно передать вектор инициализации.

На выходе будет отдана дешифрованная строка.

## hash

Для хэширования используется метод **hash** сервиса **crypt.service**.

    const hashed = hash(string);

В первом аргументе нужно передать строку. Во втором аргументе можно указать метод хеширования.

По-умолчанию используется метод **MD5**, также поддерживаются **SHA1**, **SHA256**, **SHA512**.

На выходе будет отдана захешированная строка.

> Данный метод, в чистом виде, не должен использоваться для защиты данных, для безопасного хранения данных, для кодирования данных или для создания уникального ключа!

[^ к оглавлению](#оглавление)

# Рандомайзеры

Рандомайзеры представлены методами сервиса **RandomService**, располагающегося по адресу **src/random/random.service**.

Все методы используются контроллерами группы **random**.

На данный момент резолверы реализуются в тестовом режиме и могут не работать.

Из файла экпортируется не сам класс, а новый экземпляр класса. Поэтому после импорта, можно сразу вызывать методы.

```
import randomClass from '@src/class/random.class';
...
const num = randomClass.random(1, 10);
```

[^ к оглавлению](#оглавление)

## random

**random(min, max, step = 1)**

Генератор случайных чисел.

От **min** до **max** с шагом **step** (по-умолчанию, 1).

Например вызов **random(1, 10)** выдаст число от 1 до 10.

Вызов **random(1, 10, 5)** выдаст число 5 или 10.

Вызов **random(0, 1, 0.1)** выдаст одно из чисел: 0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.

Можно указать отрицательные числа.

[^ к оглавлению](#оглавление)

## randomString

**randomString(min, max, string)**

Генератор случайных строк.

От **min** до **max** символов.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

Аргумент **string** задает строку, из которой будут браться символы.

Например: **randomSet(1, 10, 'abcdef')**.

[^ к оглавлению](#оглавление)

## randomSet

**randomSet(min, max, name)**

Генератор случайных строк из заранее составленных подборок.

От **min** до **max** символов.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

Аргумент **name** задает список подробок. Вы можете перечислить несколько подборок через запятую и/или пробел: **randomSet(1, 10, 'en, ru')**.

- **ru** - буквы русского языка в нижнем регистре,
- **RU** - буквы русского языка в верхнем регистре,
- **en** - латинские буквы в нижнем регистре,
- **EN** - латинские буквы в верхнем регистре,
- **num** - цифры,
- **hex** - цифры и буквы от 0 до F, которыми обозначаются числа в 16-ой системе исчисления,
- **sym** - символы.

[^ к оглавлению](#оглавление)

## randomNum

**randomNum(min, max)**

Генератор **строки** из случайных чисел.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomBin

**randomBin(min, max)**

Генератор **строки** из случайных чисел в 2-ой системе исчисления.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomHex

**randomHex(min, max)**

Генератор **строки** из случайных чисел в 16-ой системе исчисления.

Если аргумент **max** не задан, то число символов в строке будет равно **min**.

[^ к оглавлению](#оглавление)

## randomArray

**randomArray(n, callback)**

Генератор массива заданной длины.

Аргумент **n** задает длину массива.

В аргумент **callback** можно передать функцию, которая будет заполнять массив элементами. На вход функции подается текущий элемент.

По-умолчанию массив заполняется значениями от 0 до заданной длины.

Если вы хотите создать пустой массив, можно использовать: **randomArray(10, () => null)**.

Если вы хотите создать массив со значениями от 1, можно использовать: **randomArray(10, (i) => i + 1)**.

Вы также можете заполнить массив случайными значениями, например: **randomArray(10, () => random(1, 10))**.

[^ к оглавлению](#оглавление)

## shuffleArray

**shuffleArray(array)**

Перемешивает элементы массива случайным образом.

Возвращает новый массив, при этом старый не изменяется.

[^ к оглавлению](#оглавление)

## randomOption

**randomOption(...args)**

Выбор случайного значения, одного из переданных.

В аргумент **args** можно передать два типа значений.

- последовательность, например: **randomOption(1, 2, 3)**,

- массив, например: **randomOption([1, 2, 3])**.

[^ к оглавлению](#оглавление)

## randomEmail

**randomEmail(min, max)**

Генератор email-адреса в правильном формате.

Пределы **min** и **max** являются относительными, потому что после генерации следует небольшая чистка по условиям.

Рекомендуется запускать с параметрами по-умолчанию: **randomEmail()**

[^ к оглавлению](#оглавление)

## randomNames

**randomName(...)**

Сложный метод генерации псевдоимен.

Используется только как вспомогательный метод.

Вместо него можно использовать другие методы:

**randomNames(words = 1)**

Аргумент **words** задает число слов в имени.

На выходе отдается массив. Первым индексом идет признак рода имени:

- 0 - женский род,
- 1 - мужской род.

Чтобы получить строку с именем и фамилией, можно вызвать метод так: **name = randomRuName(2); fullName = \`\${name[1]} \${name[2]}\`**.

**randomRuNames(words = 1)**

Генератор псевдоимен с русскими буквами.

Слова генерируются в таком порядке: имя, фамилия, отчество.

**randomEnNames(words = 1)**

Генератор псевдоимен с латинскими буквами.

Слова генерируются в таком порядке: фамилия, имя, второе имя и т.д.

[^ к оглавлению](#оглавление)

# Авторизация

Обычно в системах данные пользователей и данные авторизации/аутентификации хранятся в одной таблице. В данном случае мы выделили каждую сущность отдельно:

- **auth** - данные авторизации/аутентификации, учетная запись пользователя,
- **clients** - данные клиентских приложений, созданных пользователями,
- **confirm** - данные подтверждения,
- **roles** - роли и права пользователей,
- **sessions** - сессионные данные пользователя,
- **strategies** - данные сторонних стратегий авторизации,
- **token** - работа с токенами.

Все они хранятся в своих таблицах. Для работы с ними есть свои декораторы, DTO-шки, интерфейсы, стратегии, сервисы и пр., а также свой модуль с контроллером.

Все эти таблицы связаны с таблицей **auth** по полю **id** - **auth_id**.

Такое разделение позволяет удобно разграничить данные пользователя, а также все методы работы с ними.

Например, вы можете разрешить вход по телефону и email. Вам не нужно думать о безопасности, разделении и хранении этих данных.

Также вы можете работать над авторизацией/аутентификацей изолированно от прочих данных пользователя. Это относится, например, к реализации прав, подключению сервисов OAuth, OpenID и т.д.

[^ к оглавлению](#оглавление)

## Данные авторизации

Таблица данных авторизации/аутентификации пользователей содержит следующие поля:

- id,
- created_at,
- updated_at,
- username,
- password,
- is_activated,
- is_superuser.

По полю **id** мы связываем запись авторизации/аутентификации с другими данными пользователя, хранящимися в других таблицах.

Мы предполагаем, что поле **username** будет содержать email пользователя, но можно хранить там и номер телефона, и просто логин, как было принято в старых системах.

Пароли по-умолчанию хэшируются алгоритмом **bcrypt**.

Поле **is_activated** служит для подтверждения того, что регистрация пользователя подтверждена и он является активным.

Поле **is_superuser** служит для назначения пользователю прав суперпользователя (администратора).

> На данный момент назначение прав суперпользователя возможно только вручную!

[^ к оглавлению](#оглавление)

## Протокол авторизации

Данный сервер реализует поддержку протокола OAuth 2.0 согласно спецификации [RFC6749](https://datatracker.ietf.org/doc/html/rfc6749.html).

Это означает, что вы можете использовать данный сервер также как сервер авторизации для других приложений.

[^ к оглавлению](#оглавление)

## Термины протокола авторизации

Есть пользователь, например, вы.

Есть агент или ваш веб-браузер.

Есть клиент или клиентское приложение, под которым вы работаете.

Важно понимать, что клиентское приложение - это инстанс приложения, запущенный на стороне пользователя. В каждом конкретном случае клиентское приложение работает под определенным пользователем. И хотя данные пользователя хранятся на стороне пользователя (например, в хранилище браузера или куках), инстанс приложения имеет к ним доступ.

Есть сервер авторизации.

Есть стороннее приложение, к которому вы хотите получить доступ без ввода пароля. И потом это приложение сможет обмениваться данными с клиентским приложением.

Есть сторонний сервис авторизации, поддерживающий протокол OAuth 2.0, например, google или yandex, на котором также есть ваша учетная запись, через которую вы хотите зайти на сервер авторизации и в клиентское приложение.

[^ к оглавлению](#оглавление)

## Процессы протокола авторизации

Идентификация - это проверка существования для вас пользовательского аккаунта в системе. Например, через id, логин или токена доступа.

Аутентификация - это проверка подлинности пользователя, что вы - это действительно этот пользователь, а не какой-то другой. Например, с помощью ввода пароля, пин-кода, использования биометрических данных или передачи токена доступа.

Авторизация - это выдача прав, доступных конкретному пользователю. Например, доступ к просмотру и отправке электронных писем, но отсутствие разрешения на создание новых почтовых ящиков.

Аутентификация невозможна без идентификации. А аутентификацию нельзя исключать из процесса по соображениям безопасности.

Тажке стоит понимать, что авторизация возможна без идентификации и аутентификации. Например, система может разрешить любому неопознанному пользователю доступ к просмотру документов. И несмотря на то, что пользователь может быть совершенно неопознанный и даже без аккаунта в системе, система все же его авторизовала - то есть выдала право прочитать этот документ.

[^ к оглавлению](#оглавление)

## Процесс авторизации

### Процесс авторизации на клиенте

Мы рассматриваем только те действия, которые требуют авторизации пользователя, т.е. защищенные методы нашего сервера.

Если все действия будут выполняться самим пользователем, то здесь все намного проще, потому что пользователь получает токен доступа напрямую с сервера и с этим токеном выполняет запросы.

Мы рассматриваем ситуацию, когда вместо пользователя запрсы выполняет клиентское приложение. Оно действует от его имени.

Предполагается, что клиентское приложение уже создано и имеет все необходимые права. Однако, если это не так, нужно сначала проверить и выполнить недостающие шаги из этого списка:

- зарегистрировать пользователя на сервере,
- войти на сервер, получив токен авторизации,
- зарегистрировать клиентское приложение.

Как это сделать, описано в другом разделе.

Клиентское приложение отправляет запрос на сервер. Это может быть запрос данных пользователя или просто запрос на проверку существования пользователя. Естественно, такой запрос должен быть защищен.

Если пользователь на клиенте уже имеет токен доступа, то он сразу авторизуется.

Если в процессе авторизации происходит ошибка, например, токен доступа просрочен, то эта ошибка возвращается клиенту в ответе от сервера.

Тогда клиент должен отправить запрос на сервер с обновлением токена доступа, а затем повторить исходный запрос.

Если у пользователя на клиенте нет токена доступа, то клиенту (именно клиенту) нужно этот токен получить. Для этого клиент отправляет на сервер соответствующий запрос.

Нужно понимать, что всю ответственность по идентификации, аутентификации и авторизации пользователя сервер берет на себя.

[^ к оглавлению](#оглавление)

### Схема процесса авторизации на сервере

    +--------+       +---------+                                 +---------------+
    | Клиент |------>| Агент   |-------------------------------->| Сервер        |
    |        |  (A)  | пользо- |  (A) Авторизация клиента        | авторизации   |
    |        |       | вателя  |                                 |               |
    |        |       |         |-------------------------------->|               |
    |        |       |         |  (B) Авторизация пользователя   |               |
    |        |       |         |                                 |               |
    |        |<------|         |<--------------------------------|               |
    |        |  (C)  |         |  (C) Ответ с кодом авторизации  |               |
    |        |       +---------+                                 |               |
    |        |                                                   |               |
    |        |-------------------------------------------------->|               |
    |        |  (D) Запрос на выдачу токена с кодом авторизации  |               |
    |        |                                                   |               |
    |        |<--------------------------------------------------|               |
    |        |  (E) Токен доступа и токен обновления             |               |
    +--------+                                                   +---------------+
                                                                       |
                                                                       | (B)
                                                                       V
                                                                 +---------------+
                                                                 | Пользователь  |
                                                                 +---------------+

[^ к оглавлению](#оглавление)

### Авторизация клиента на сервере

Клиентское приложение отправляет запрос на сервер авторизации, предоставляя ему свой секретный ключ client_secret и ссылку на редирект redirect_uri.

Для валидности запросов, ключ client_secret должен передаваться любым из следующих двух способов:

1. В заголовке client_secret. Например:

   client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM

2. В теле POST-запроса. Например:

   {
   "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI4ODcwNTlkZC0yODE0LTQzYjQtODFhYy1kMmJjMjFjYzU2NGYiLCJpYXQiOjE3MDkwNzMxOTV9.YDdtSVpviT9xIzd5wlBqj-kaSkwvDD3RnfBpwPBnPFM"
   }

Сервер видит ключ, проверяет его, аутентифицирует клиентское приложение и авторизует запрос.

Фактически это реализовано через декоратор клиента **@Client**.

[^ к оглавлению](#оглавление)

### Авторизация пользователя на сервере

Сервер редиректит пользователя на свою же страницу входа, где пользователь должен ввести логин и пароль.

Предполагается, что все эти шаги происходят в агенте пользователя (например, в браузере), а значит редиректы будут отработаны правильно.

Это сделано для того, чтобы клиентское приложение ничего не знало о логине и пароле пользователя. Все это происходит вне его работы, здесь есть только пользователь и сервер авторизации.

Если данные введены правильно и пользователь существует, сервер авторизует пользователя.

[^ к оглавлению](#оглавление)

### Передача кода авторизации

Теперь сервер должен передать клиенту код авторизации. Но происходит это не в ответе, а снова через редирект.

Дело в том, что у клиента зарегистрированы разрешенные им самим redirect_uri. Такой же параметр, redirect_uri, был получен сервером от клиента.

Совпадение полученного redirect_uri с одним из зарегистрированных является частью авторизации клиента.

Теперь сервер отправляет клиенту запрос по полученному redirect_uri, передавая в параметрах код авторизации.

Такой способ исключает перехват кода авторизации злоумышленником.

[^ к оглавлению](#оглавление)

### Передача токена доступа

Клиент принимает запрос от сервера на redirect_uri вместе с кодом авторизации.

После этого он инициирует встречный запрос на сервер, предоставляя свои данные клиента и полученный код авторизации.

Сервер авторизует этот запрос по полученным данным и проверяет код авторизации на валидность.

Если все в порядке, то сервер выдает ответ (теперь уже именно ответ) с токенами доступа и обновления, а также некоторыми другими параметрами, указанными в спецификации.

По сути, код авторизации это некий код, который клиент обменивает у сервера на токен доступа.

[^ к оглавлению](#оглавление)

## Методы авторизации

### Метод авторизации authorization code

Относится к контроллеру **OpenAuthController**.

RestAPI:

    GET /auth

Параметры:

    {
        "response_type": "code",
        "client_id": "b57937e9-31d4-4741-a59f-acb8c4f88539",
        "redirect_uri": "https://myapp.com/oauth/redirected"
    }

Ответ:

    Redirect
    https://myapp.com/oauth/redirected
    ?code=ZDVkNWRkMjktNmU3NC00YmIyLWEwZTktMDY2ZjdmOGJjNDYzLmh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9jbGllbnRzL3Rva2VuLjE3MDk4MDY3MDQ5MDg=
    &client_id=b57937e9-31d4-4741-a59f-acb8c4f88539

Возврат параметра client_id не является обязательным условием и это не документировано в спецификации. Однако это позволяет облегчить процесс получения токена доступа.

[^ к оглавлению](#оглавление)

### Метод авторизации implicit grant

Относится к контроллеру **OpenAuthController**.

RestAPI:

    GET /auth

Заголовки:

    Client_secret: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJiNTc5MzdlOS0zMWQ0LTQ3NDEtYTU5Zi1hY2I4YzRmODg1MzkiLCJpYXQiOjE3MDk4MDg0NDF9.oBQw2e3_h_FjywdkF85-jxosIRTL0CQa8Clj2BP4DwQ

Параметры:

    {
        "response_type": "token",
        "client_id": "b57937e9-31d4-4741-a59f-acb8c4f88539",
        "redirect_uri": "https://myapp.com/oauth/redirected"
    }

Ответ:

    Redirect
    https://myapp.com/oauth/redirected
    ?token_type=Bearer
    &expires_in=900
    #access_token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA1MjY4LCJleHAiOjE3MDk4MDYxNjh9.2JqBN87dkD8zGdaHFYFbn3qE0Fv6o6yGhmgX5xSqGu4

Спецификация предусматривает упрощенный механизм - Неявное разрешение. Когда сервер авторизации сразу возвращает токен доступа. В результате мы сокращаем число запросов, но проигрываем в безопасности.

В спецификации сказано, что при использовании Неявного разрешения, мы должны обеспечить дополнительные проверки, чтобы клиентское приложение могло убедиться, что этот токен действительно принадлежит этому пользователю.

[^ к оглавлению](#оглавление)

### Метод входа в систему

Относится к контроллеру **FormsAuthController**.

Вход в систему осуществляется через стандартную форму входа. Она относится к тому же процессу, что и авторизация пользователя на сервере.

RestAPI:

    POST /auth/login

Параметры:

    {
        "username": "user@mail.com",
        "password": "123456"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MDk4MDk0ODl9.xnZ4OLFjkTZ_3fhoyYReFKyFNmNKmT8TUUCNzt6EgEM",
        "token_type": "Bearer",
        "expires_in": 900,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

Ответ с ошибкой:

    Redirect FORM_LOGIN?statusCode=401&message=Invalid%20password&error=Unauthorized

Ответ с редиректом из клиентского приложения:

    Redirect /auth?client_id=CLIENT_ID&response_type=RESPONSE_TYPE&redirect_uri=REDIRECT_URI

Фактически, это обертка над методом получения токена доступа, созданная специально для форм.

В случае ошибки она делает редирект обратно на форму входа с передачей состояния ошибки в параметрах запроса.

Кроме непосредственно входа через ввод логина и пароля, можно использовать вход через сторонние сервисы авторизации, которые поддерживают протокол OAuth 2.0.

Если вы хотите узнать подробнее, вам нужно смотреть раздел работы со стратегиями библиотеки passport.js.

[^ к оглавлению](#оглавление)

### Метод регистрации

Относится к контроллеру **FormsAuthController**.

Регистрация нового пользователя.

После регистрации создаются новая запись в таблице **auth**.

Если регистрация проходит успешно, то автоматически генерируются данные с токенами и выводятся в ответе.

Также автоматически генерируется код подтверждения, сохраняется в таблице **confirm** и выводится в ответе.

RestAPI:

    POST /auth/register

Параметры:

    {
        "username": "user@mail.com",
        "password": "123456"
    }

Ответ:

    {
        "id": "...",
        "createdAt": "2024-04-24T21:02:09.385Z",
        "updatedAt": "2024-04-24T21:02:09.385Z",
        "username": "user@mail.com",
        "password": "$2a$10$lCopu3GG.RStYEh4uEY0teqPUZb.xmsdDYvfMmN9BsFejAblc2LW6",
        "isActivated": false,
        "token": {
            "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjE1IiwiaWF0IjoxNzEzOTkyNTI5LCJleHAiOjE3MTM5OTM0Mjl9.ReMBHHwxPRVYtH2dnIvundHl7bUbXAl8GcmCeK_Itwo",
            "expires_in": 900,
            "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjE1IiwiaWF0IjoxNzEzOTkyNTI5LCJleHAiOjE3MTY1ODQ1Mjl9.IhESO7kDMXCVxb_DkGLWVef8mFPQ42b71iaMjqUcHoc"
        },
        "confirm": {
            "id": "...",
            "createdAt": "2024-04-24T21:02:09.419Z",
            "updatedAt": "2024-04-24T21:02:09.419Z",
            "code": "45be1642-763d-4a78-bed5-4d76837444c9"
        }
    }

> Для сохранения временной зоны пользователя, рекомендуем передавать ее в одном из полей формы регистрации. Сервер позволяет отслеживать только свою временную зону.

[^ к оглавлению](#оглавление)

### Механизм подтверждения регистрации

Механизм подтверждения используется для активации зарегистрированного пользователя.

Как минимум, это гарантирует то, что email пользователя реально существует.

Эта функция используется по-умолчанию.

Вы можете отключить механизм подтверждения. Для этого достаточно записывать значение **true** в поле **is_activated** при регистрации.

По-умолчанию, код подтверждения генерируется в виде **uuid**. Но вы можете поменять генератор. Для этого в сервисе **auth** в методе **register** поменяйте метод **confirmCreate** на **confirmGenerate**. Вы также можете изменить сам метод генерации внутри метода **confirmGenerate**.

> Обратите внимание, код подтверждения хранится в виде строки!

> Каждый код должен быть уникальным.

Например, в методе **confirmGenerate** после генерации кода проверяется существование данного кода в таблице **confirm**, и если код повторяется, генерируется другой код.

Если пользователь будет сразу же активирован, генерацию кода нужно убрать из метода регистрации.

Двухфакторная аутентификация подразумевает подтверждение входа дополнительным кодом каждый раз при входе пользователя в систему. Для этого достаточно поменять код таким образом, чтобы поле **is_activated** сбрасывалось после каждого успешного входа.

[^ к оглавлению](#оглавление)

### Метод подтверждения регистрации

Относится к контроллеру **FormsAuthController**.

После регистрации, аккаунт, возможно, потребуется активировать.

При регистрации был сгенерирован код подтверждения и отправлен на почту, указанную при регистрации. Этот код нужно отправить на специальный эндпоинт.

Если активация проходит успешно, то аккаунт подтверждается и выводится ответ **true**. Запись в таблице **confirm** удаляется.

RestAPI:

    GET /auth/confirm/:code

Ответ:

    true/false

Также этот механизм можно использовать в качестве двухфакторной аутентификации.

[^ к оглавлению](#оглавление)

### Запрос на восстановление пароля

Относится к контроллеру **FormsAuthController**.

При запросе генерируется код подтверждения.

Дальше требуется переход по специальной ссылке, отправленной на почту, указанную в качестве логина при регистрации.

Это минимальная мера безопасности.

Если генерация проходит успешно, то выводится ответ **true**. Создается запись в таблице **confirm**.

RestAPI:

    POST /auth/restore

Параметры:

    {
        "username": "user@mail.com"
    }

Ответ:

    true/false

### Метод восстановления пароля

Относится к контроллеру **FormsAuthController**.

Также один из стандартных методов.

В ссылке должен присутствовать код подтверждения.

Если смена пароля проходит успешно, то выводится ответ **true**. Запись в таблице **confirm** удаляется.

RestAPI:

    POST /auth/restore/:code

Параметры:

    {
        "username": "user@mail.com",
        "password": "123456"
    }

Ответ:

    true/false

В целях безопасности, никакие данные в ответе не возвращаются. Автоматического входа в систему тоже не происходит. После смены пароля нужно будет войти в систему самостоятельно.

[^ к оглавлению](#оглавление)

# Клиентские приложения

## Данные клиента

Данные клиента хранятся в таблице **clients**. В базовом варианте они содержат поля:

- id - порядковый индекс клиента в таблице,
- createdAt - дата создания записи,
- updatedAt - дата последнего изменения записи,
- client_id - идентификатор клиента, который назначается при создании клиента в формате uuid, также можно задать идентификатор клиента самостоятельно как уникальное имя клиента,
- client_secret - секретный ключ клиента, назначается при создании в виде jwt токена, содержащего в себе client_id,
- client_password - пароль клиента, необязательное поле, которое нужно только для метода получения токена сlient credentials, при желании задается пользователем при регистрации клиента, хешируется, как и пароль пользователя
- client_type - один из разрешенных в спецификации OAuth 2.0 типов клиента, по-умолчанию public,
- client_uri - хост клиента, с которого будут поступать запросы, нужен для реализации средств дополнительной безопасности,
- title - заголовок клиента,
- description - описание клиента,
- code - код авторизации клиента, сохраняется только на время от выдачи кода и до его подтверждения,
- publishedAt - дата, начиная с которой, клиент будет доступен для работы,
- isPublished - флаг доступности клиента, если он доступен по дате.

Также согласно спецификации, для клиента должен быть зарегистрирован **redirect_uri**. Это адрес, на который будет обращаться клиент, например, для передачи токена после авторизации клиента или пользователя.

Клиент может иметь несколько таких **redirect_uri**. На сервере они хранятся в отдельной таблице **redirects**, в поле **uri**. Они связаны с клиентами по полю **client_id** с отношением многие-к-одному.

[^ к оглавлению](#оглавление)

## Декораторы клиента

Модуль клиента дает возможность использовать два декоратора.

Декоратор **@Client** работает по аналогии с декоратором **@Auth**. Его можно использовать для защиты методов модуля клиента.

Декоратор **@Client** распознает клиента двумя способами:

- через заголовок **client_secret**,
- через параметр POST запроса **client_secret**.

Декоратор аргумента **@SelfClient** работает по аналогии с декоратором **@Self**. Он передает **id** клиента внутрь метода.

> Как и **@Self**, **@SelfClient** не будет работать без декоратора метода **@Client**!

[^ к оглавлению](#оглавление)

## Регистрация клиента

Метод защищен, для регистрации клиента требуется авторизация пользователя. Иначе любой гость сможет создавать клиентов.

По-умолчанию **client_id** генерируется как строка **uuid**. Также можно передать необязательный параметр "client_id", в котором указать желаемое имя клиента. Если такое имя занято, будет выброшена ошибка.

RestAPI:

    POST /clients/register

Заголовки:

    Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA0MTc2LCJleHAiOjE3MDk4MDUwNzZ9.5KFHVcKeTfDe_sQZzIIEN03HD4zSIXZQxCI34osK9ME

Параметры:

    {
        "title": "Мое приложение",
        "description": "Это мое приложение",
        "client_id": "myapp",
        "client_uri": "myapp.com",
        "redirect_uri": "https://myapp.com/oauth/redirected"
    }

Ответ:

    {
        "id": "37",
        "title": "Мое приложение",
        "description": "Это мое приложение",
        "client_uri": "https://myapp.com/",
        "redirect_uri": "https://myapp.com/oauth/redirected",
        "client_id": "b57937e9-31d4-4741-a59f-acb8c4f88539",
        "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiI1Njc2NDczMy1jZjc4LTRkN2YtODMyMi01NzkxZWI3NTIwZjgiLCJpYXQiOjE3MDk4MDQxODd9.2lMaod_pvcFq9xGB4s4KwHYqQV_KTMTJSQrflGub1PI",
        "client_password": null,
        "client_type": "public",
        "code": null,
        "publishedAt": "2024-03-07T09:36:27.025Z",
        "isPublished": true,
        "createdAt": "2024-03-07T09:36:27.025Z",
        "updatedAt": "2024-03-07T09:36:27.025Z"
    }

[^ к оглавлению](#оглавление)

# Роли и права

**roles** - роли и права пользователей.

Данный раздел не написан.

Данный функционал пока не реализован.

[^ к оглавлению](#оглавление)

# Сессии

Мы считаем сессией любой авторизованный вход в систему и дальнейшую работу с ней.

Сессия прекращается в тот момент, когда прекращается работа с системой. Это может происходить в трех случаях:

- истекает время действия токена,
- истекает время сессии,
- пользователь выходит из системы.

Сессионные данные хранятся на стороне сервера. В базе данных мы держим только историю подключений.

В сессионные данные записывается актуальный **refresh** токен. Благодаря этому, мы можем проверить подлинность токена и всей сессии.

Мы можем также открыть несколько сессий для одного пользователя с разных устройств.

Сессия не содержит никаких персональных данных. Хранить другую информацию небезопасно, но это и не требуется.

Также наличие сессии помогает убедиться, что запросы от пользователя не являются поддельными.

Сессии реализованы двумя механизмами:

- встроенный механизм сессий и сессионные данные,
- информация о подключениях пользователей в базе данных.

По-умолчанию сессионные данные хранятся в файлах в каталогах

    /sessions

[^ к оглавлению](#оглавление)

## Информация о сессии

Мы логируем в базу данных информацию о каждом подключении пользователя, когда происходит вход в систему и создается новая сессия.

Для этого мы выделили отдельную таблицу **sessions**.

Здесь хранится информация о подключении:

- время подключения (created_at),
- ip-адрес,
- агент пользователя (данные браузера),
- адрес ссылки (referrer).
- метод подключения (get/post).

Также cюда относятся локальные предпочтения пользователя, такие как код языковой страницы (ru, en и т.д.) и часовой пояс:

- locale (первый из заголовка accept-language),
- timezone (из заголовка timezone).

> Для сохранения временной зоны пользователя, рекомендуем передавать ее в одном из заголовков. Сервер позволяет отслеживать только свою временную зону.

Для истории сессий мы сделали отдельную сущность **sessions** со своими методами.

[^ к оглавлению](#оглавление)

## Проверка сессии

Проверка запросов целиком и полностью передана **access** токену.

Сессия является дополнительным механизмом, который помогает защитить **refresh** токен в случае его утечки.

Но вы можете расширить ответственность сессии. Например, благодаря связке authId, ip-адрес, userAgent и token, можно с определенной степенью достоверности валидировать пользователя и список разрешенных устройств, с которых он обычно входит в систему.

Теоретически, можно реализовать и классический механизм проверки сессии:

- генерация сессионного токена,
- передача клиенту,
- хранение токена в куки,
- передача токена от клиента на сервер в заголовке при каждом запросе,
- проверка сервером токена, полученного от клиента с токеном в сессионных данных.

Но мы не видим в этом смысла, т.к. механизм **jwt** токенов полностью заменяет этот механизм.

[^ к оглавлению](#оглавление)

# Стратегии авторизации

## Декораторы методов

У нас реализован механизм с двумя **jwt** токенами:

- **access_token** - токен доступа,
- **refresh_token** - токен обновления.

Токены кодируются, но не шифруются. Это значит, что прочесть содержимое токена можно в любом случае. Защита обеспечивается проверкой подлинности подписи. Эта подпись уже зашифрована ключем, который хранится только на сервере.

Мы предлагаем использовать декоратор метода **@Auth**, который разрешает доступ к ресурсу только вошедшему пользователю.

> Учетная запись пользователя должна быть активирована! Это делается подтверждением регистрации.

Декоратор имеет один аргумент, являющийся типом. Сейчас типов два - **undefined** для контроллеров (задан по-умолчанию) и **gql** для резолверов.

Пример для контроллеров:

    @Auth()

Пример для резолверов:

    @Auth('gql')

Внутри этот декоратор использует защитников:

- GqlAuthGuard,
- JwtAuthGuard.

Защитники **GqlAuthGuard** и **JwtAuthGuard** используют встроенный механизм библиотеки **jwt**. По-сути, мы только задаем правила стратегии **JwtStrategy** в файле **src/auth/strategy/jwt.strategy**.

А конкретно:

- получаем токен из поля **Authorization** в формате **Bearer**,
- задаем ключ для шифрования подписи **jwt** через **JWT_ACCESS_SECRET**,
- разрешаем или запрещаем учитывать время действия токена через **JWT_EXPIRES**,
- проверяем валидность данных, хранящихся в токене, сравнивая по базе данных.

Из базы данных, из таблицы **auth**, запрашивается запись по **auth.id**, и если такая запись существует, то вход подтверждается.

Если токен будет перехвачен злоумышленником, то расшифровка **auth.id** не позволит ему сопоставить значение из запроса и данные пользователя.

[^ к оглавлению](#оглавление)

## Декораторы аргументов

Для получения данных пользователей, у нас есть декоратор аргумента **@Self**.

> Декоратор аргумента **@Self** не будет работать без декоратора метода **@Auth**!

Декоратор имеет один аргумент, являющийся типом. Сейчас типов два - **undefined** для контроллеров (задан по-умолчанию) и **gql** для резолверов.

Пример для контроллеров:

    ...(@Self() auth: AuthDto) {
        const { id } = auth;
        ...
    }

Пример для резолверов:

    ...(@Self('gql') auth: AuthDto) {
        const { id } = auth;
        ...
    }

Пользователи **users** и данные авторизации/аутентификации **auth** связаны между собой отношением один-к-одному по полю **id** (**auth.id**).

Поэтому дальше вы можете запросить из базы данные пользователя по его **auth.id**. Например:

```
return await this.usersService.usersGetByAuthId(id);
```

Использование этого декоратора позволяет управлять данными именно того пользователя, от которого идет запрос.

Предполагается, что пользователь не может просто так получить свои данные для входа, но система позволяет их поменять. Примером служит смена и восстановление пароля.

[^ к оглавлению](#оглавление)

## Защитники

Защитники используются для ограничения доступа к таким ресурсам как контроллеры и резолверы.

```
  @Get('...')
  @UseGuards(...)
  async ...() {
    ...
  }
```

Защитники используют встроенный класс **AuthGuard**, который, в свою очередь, использует различные стратегии. Вы можете расширить его и переопределить его методы.

Например, можно задать цепочку стратегий:

```
export class ... extends AuthGuard(['my_strategy_1', 'my_strategy_2']) ...
```

Защитники выполняют только одну роль - авторизацию. Т.е. они определяют, пропустить или отклонить запрос.

```
import { ExecutionContext, Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class ... extends AuthGuard(...) {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    ...
  }
}
```

Отсюда видно, что метод **canActivate** получает контекст, т.е. все данные запроса, и возвращает true или false.

Вы можете переназначить родительские методы. Частая практика - переназначение **getRequest** для запросов **GraphQL**:

```
  getRequest(context: ExecutionContext) {
    const ctx = GqlExecutionContext.create(context);
    return ctx.getContext().req;
  }
```

Вы также можете вызывать родительские методы, например **canActivate**:

```
return await super.canActivate(context);
```

Вы можете дополнять его своими методами и вызывать методы сторонних сервисов, таких как **authService**.

Добавлять защитников к запросу можно при помощи декоратора **@UseGuards(...)**. Но вы также можете создать свой декоратор, который будет вызывать защитников.

```
export const MyGuard = () => {
  return applyDecorators(UseGuards(MyGuard));
}
```

Использовать его будет намного проще:

```
  @Get('...')
  @MyGuard()
  async ...() {
    ...
  }
```

Также в декоратор вы можете добавить множество проверок и условий, последовательность вызова защитников, аргументы и пр.

[^ к оглавлению](#оглавление)

## Стратегии

Для входа через сторонние сервисы используется библиотека **passport.js**.

В таблице **strategies** созданы следующие поля:

- name - стратегия **passport.js**,
- uid - идентификатор, который мы получаем из сервиса,
- json - данные в формате json, полученные при авторизации через эту стратегию,
- access_token - токен доступа, полученный при авторизации через эту стратегию,
- refresh_token - токен обновления, полученный при авторизации через эту стратегию.

> Токены в базе данных хранятся в зашифрованном виде!

В **passport.js** сервисы аутентификации называют стратегиями.

По-умолчанию настроена стратегия **google** по протоколу **OAuth 2.0**.

Каждая стратегия имеет свои особенности. Как правильно ее использовать, нужно читать в официальной документации по каждой стратегии.

Неизменным остается только принцип объявления стратегии:

```
@Injectable()
export class ... extends PassportStrategy(Strategy) {
  constructor(
    ...
  ) {
    super({
      ...
    });
  }

  async validate(...) {
    ...
    return ...;
  }
}
```

Вы экспортируете встраиваемый класс (декоратор **@Injectable()**), который расширяет базовый класс **PassportStrategy** с типом **Strategy**, полученным из нужной библиотеки. Например, из **passport-google-oauth20** или **passport-jwt**.

Также каждая стратегия имеет свое имя по-умолчанию (например, **jwt** для **passport-jwt**). Но вы можете задать свое имя:

```
export class ... extends PassportStrategy(Strategy, 'my_strategy_type') ...
```

Далее, в конструкторе, нужно обратиться к родителю через функцию **super()**, в которой передать объект с нужными для стратегии данными.

И последнее - нужно задать метод **validate**. В одном или нескольких аргументах он получает входящие данные. Например, для стратегии **passport-jwt** это объект данных, полученных из декодированного токена.

На выходе метод **validate** должен вернуть объект, доступный затем из поля **request.user** для следующих в очереди middleware. Из этого объекта вы сможете получить нужные вам данные пользователя.

> Стоит обратить внимание, что эти данные пользователя являются безопасными с точки зрения фреймворка и считаются актуальными, т.е. на момент аутентификации должны быть получены из базы данных.

Для того, чтобы стратегия заработала, нужно поместить ее в секцию **providers** модуля **auth.module**.

Подключаются стратегии в защитниках, например:

```
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class ... extends AuthGuard('my_strategy_type') {}
```

Здесь используется метод **AuthGuard** для работы с **passport.js**. Стратегия вызывается по имени, переданному в качестве аргумента. В данном случае **jwt**. Если вы задали стратегии свое имя, нужно прописать его.

[^ к оглавлению](#оглавление)

## Токены стратегий

После входа через сторонние сервисы, вам может потребоваться отправлять запросы от имени своего пользователя, авторизованного в этом сервисе.

Для этих целей мы сохраняем в базе данных токены, полученные при авторизации пользователя.

Однако в целях обеспечения безопасности, эти токены хранятся в зашифрованном виде.

Шифрование и дешифрование токенов происходит с помощью встроенных методов **encrypt** и **decrypt** сервиса **crypt.service**;

[^ к оглавлению](#оглавление)

## Подключение сервиса google

Для авторизации/аутентификации через сервис google мы используем стратегию **GoogleStrategy** (с именем **google**) из библиотеки **passport-google-oauth20** и защитника **GoogleAuthGuard**.

Чтобы подключить сервис google, вам понадобится аккаунт разработчика. Получив его, перейдите в личный кабинет разработчика. Там вы должны будете создать новое веб-приложение, отвечающее за вход на сторонних для google ресурсах.

Вам нужно получить id клиента/приложения и ключ, который может называться token, secret или api key.

Вам также нужно указать страницу редиректа после успешного входа.

Мы вынесли эти данные в файл **.env**:

```
GOOGLE_CLIENT_ID=...
GOOGLE_CLIENT_SECRET=...
GOOGLE_CLIENT_CALLBACK=...
```

Пути мы задаем с помощью контроллера **strategies**.

Мы используем следующий шаблон:

- /strategies/google/login - для пути к форме входа,
- /strategies/google/redirect - для пути редиректа.

Для ограничения доступа к этим путям, мы создаем защитника **GoogleStrategyGuard**:

    /strategies/guard/google.guard

И применяем его в контроллере:

```
  @Get('google/login')
  @UseGuards(GoogleAuthGuard)
  async googleLogin() {
    ...
  }

  @Get('google/redirect')
  @UseGuards(GoogleAuthGuard)
  async googleRedirect() {
    ...
  }
```

> По такому же принципу вы можете подключить любой похожий сервис. Мы выбрали сервис google для примера, потому, что он работает с приложением на локальной машине. Поэтому его удобно тестировать. Другие сервисы работают только с проектами, запущенными онлайн.

[^ к оглавлению](#оглавление)

# Токены

## Токен доступа

Токен доступа, **access_token**, задается переменными окружения:

- **JWT_SECRET** - секретное слово для подписи токена,
- **JWT_ACCESS_EXPIRES** - время жизни токена.

> Время жизни токена по-сути определяет время простоя, в течение которого пользователя не выкинет из приложения, когда он не пользуется backend-ом.

> Время жизни токена работает только в том случае, если задана константа **JWT_EXPIRES**.

Мы рекомендуем сделать короткое время жизни токена - от нескольких секунд до нескольких минут.

Слишком маленькое время вызовет дополнительную нагрузку на сервер и клиент, т.к. будут часто выполнятся запросы на генерацию нового токена доступа.

Слишком большое время создаст риск безопасного использования. Например, если злоумышленник каким-то образом перехватит токен, он сможет пользоваться им в течение оставшегося времени.

На самом деле, время жизни токена доступа лучше назначать исходя из того, сколько времени может уйти на ряд стандартных операций, которые производит пользователь, заходя в ваше приложение.

В токене доступа хранится только **id** учетной записи и тип токена **type** в значении **access**. Хранить в токене личные данные нельзя. Бехопасность достигается только проверкой зашифрованной подписи. Сами же данные внутри токена легко дешифруется.

Токен доступа отправляется клиенту в теле ответа, а затем принимается в заголовке **authorization** в виде **bearer token**.

На стороне клиента **access_token** можно хранить во временном хранилище, например в менеджере состояний.

[^ к оглавлению](#оглавление)

## Токен обновления

Для генерации токена обновления, **refresh_token**, используются данные из переменных окружения:

- **JWT_SECRET** - секретное слово для подписи токена,
- **JWT_REFRESH_EXPIRES** - задает время жизни токена.

Токен обновления работает в точности так же, как и токен доступа.

Тип токена **type** устанавливается в значении **refresh**. Хранение и проверка типов предотвращает использование токена обновления в качестве токена доступа и наоборот.

По-умолчанию, время жизни устанавливается в 30 дней. Мы не рекомендуем делать время жизни токена слишком маленьким. Иначе пользователю придется часто выполнять вход.

Токен обновления не нужно передавать с каждым запросом, он не участвует ни в каких других процессах и нужен только для генерации токена доступа.

На стороне клиента **refresh_token** удобнее всего хранить в локальном хранилище, например в localStorage или sessionStorage.

[^ к оглавлению](#оглавление)

## Проверка токенов

Проверка **access_token** проходит средствами библиотеки **jwt**. По-сути мы проверяем только шифрованную подпись токена и время его действия.

Если проверка не пройдена, мы возвращаем ошибку.

Получив ее, клиент должен отправить запрос на обновление **access_token**. Для этого ему нужно предоставить **refresh_token**.

Токен **refresh_token** проходит ту же проверку, что и **access_token**. Но еще дополнительно проверяется его присутствие в данных сессии.

Если все хорошо, генерируется новая пара токенов, которые передаются клиенту обратно, как после авторизации. Новый **refresh_token** обновляется в сессионных данных.

Теперь клиент должен повторить запрос с новым **access_token**.

Для закрытия сессии клиент должен очистить оба токена на своей стороне.

Мы также рекомендуем посылать запрос на закрытие сессии и очистку сессионных данных.

[^ к оглавлению](#оглавление)

## Методы токенов

### Получение токена доступа по типу password

С помощью этого метода можно обновить токен доступа для пользователя.

Этот метод выдает токен после проверки данных пользователя.

Пример использования - для авторизации через форму входа.

RestAPI:

    POST /token

Параметры:

    {
        "grant_type": "password",
        "username": "user@mail.com",
        "password": "123456"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MDk4MDk0ODl9.xnZ4OLFjkTZ_3fhoyYReFKyFNmNKmT8TUUCNzt6EgEM",
        "token_type": "Bearer",
        "expires_in": 900,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

[^ к оглавлению](#оглавление)

### Получение токена доступа по типу refresh token

С помощью этого метода можно обновить токен доступа для пользователя, клиента или персонажа.

Сервер определяет назначение по входящим данным.

RestAPI:

    POST /token

Параметры для пользователя:

    {
        "grant_type": "refresh_token",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

Параметры для клиента:

    {
        "grant_type": "refresh_token",
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M",
        "client_id": "s6BhdRkqt3",
        "client_secret": "7Fjfp0ZBr1KtDRbnfVdmIw"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MDk4MDk0ODl9.xnZ4OLFjkTZ_3fhoyYReFKyFNmNKmT8TUUCNzt6EgEM",
        "token_type": "Bearer",
        "expires_in": 900,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

[^ к оглавлению](#оглавление)

### Получение токена доступа по типу сlient credentials

С помощью этого метода можно обновить токен доступа для клиента, предоставив его данные.

RestAPI:

    POST /token

Параметры:

    {
        "grant_type": "client_credentials",
        "client_id": "b57937e9-31d4-4741-a59f-acb8c4f88539",
        "client_secret": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjbGllbnRfaWQiOiJiNTc5MzdlOS0zMWQ0LTQ3NDEtYTU5Zi1hY2I4YzRmODg1MzkiLCJpYXQiOjE3MDk4MDg0NDF9.oBQw2e3_h_FjywdkF85-jxosIRTL0CQa8Clj2BP4DwQ"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MDk4MDk0ODl9.xnZ4OLFjkTZ_3fhoyYReFKyFNmNKmT8TUUCNzt6EgEM",
        "token_type": "Bearer",
        "expires_in": 900,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

[^ к оглавлению](#оглавление)

### Получение токена доступа по типу person credentials

С помощью этого метода можно обновить токен доступа для персонажа, предоставив его данные.

RestAPI:

    POST /token

Параметры:

    {
        "grant_type": "person_credentials",
        "username": "person@mail.com",
        "password": "123456"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJzb25faWQiOiIxIiwidHlwZSI6ImFjY2VzcyIsImlhdCI6MTcxNjE1NTg1MiwiZXhwIjoxNzE2MjQyMjUyfQ.Xc9Jinkl6fZdz8zRPvugm84ReFhevD7lCA33ea2VWx8",
        "token_type": "Bearer",
        "expires_in": 86400,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJwZXJzb25faWQiOiIxIiwidHlwZSI6InJlZnJlc2giLCJpYXQiOjE3MTYxNTU4NTIsImV4cCI6MTcxODc0Nzg1Mn0.aIEZAKjlSiPNABkHrRX9nCjEogQ0lKsZos8iXJBeP6M"
    }

> Тип гранта **person_credentials** отсутствует в официальной документации. Однако стандарт разрешает расширять типы грантов для нужд системы.

[^ к оглавлению](#оглавление)

### Получение токена доступа по типу authorization code

Это ответная часть процесса авторизации пользователя через клиентское приложение.

Здесь сервер предоставляет токены в ответ на правильный код авторизации, который ранее был сгенерирован и записан для этого клиентского приложения.

По спецификации, передаваемый параметр client_id является обязательным для неавторизованного пользователя и рекомендуемым для авторизованного.

Метод также не является защищенным.

RestAPI:

    POST /token

Параметры:

    {
        "grant_type": "authorization_code",
        "code": "ZDVkNWRkMjktNmU3NC00YmIyLWEwZTktMDY2ZjdmOGJjNDYzLmh0dHA6Ly9sb2NhbGhvc3Q6MzAwMC9jbGllbnRzL3Rva2VuLjE3MDk4MDY3MDQ5MDg=",
        "client_id": "b57937e9-31d4-4741-a59f-acb8c4f88539",
        "redirect_uri": "https://myapp.com/oauth/redirected"
    }

Ответ:

    {
        "access_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MDk4MDk0ODl9.xnZ4OLFjkTZ_3fhoyYReFKyFNmNKmT8TUUCNzt6EgEM",
        "token_type": "Bearer",
        "expires_in": 900,
        "refresh_token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjExIiwiaWF0IjoxNzA5ODA4NTg5LCJleHAiOjE3MTI0MDA1ODl9.De3n3d6TG-sime-vE9JKjGFO0gLJttrdzOJQyyfJr0M"
    }

[^ к оглавлению](#оглавление)

# Персонажи

В системе могут быть участники, зарегистрированные другими пользователями.

Таким образом, они получаются неравноправными участниками системы, по сравнению с обычными пользователями.

Например, им недоступен личный кабинет пользователя и другие разделы приложения, однако у них может быть свой раздел и свой кабинет. Также им доступна своя авторизация, отдельная от авторизации обычных пользователей.

Для таких участников предусмотрена отдельная сущность - персонажи.

[^ к оглавлению](#оглавление)

## Данные персонажа

Обычно данные персонажей совпадают с данными пользователей.

Однако персонаж самостоятельно не может поменять эти данные, т.к. по-умолчанию доступ к этим операциям назначен только для пользователя, создавшего персонаж.

[^ к оглавлению](#оглавление)

## Декораторы персонажа

Модуль персонажа дает возможность использовать два декоратора.

Декоратор **@Person** работает по аналогии с декоратором **@Auth**. Его можно использовать для защиты методов модуля персонажа.

Декоратор **@Person** получает токен персонажа из поля **Authorization** в формате **Bearer**. В токене содержится только **id** персонажа и никаких других данных.

Декоратор аргумента **@SelfPerson** работает по аналогии с декоратором **@Self**. Он передает **id** персонажа внутрь метода.

> Как и **@Self**, **@SelfPerson** не будет работать без декоратора метода **@Person**!

[^ к оглавлению](#оглавление)

## Регистрация персонажа

Так как записи персонажей связаны с учетными данными пользователей, регистрация персонажа доступна только аутентифицированным пользователям.

Персонажи создаются методом **create**, который переопределяет стандартный метод.

Для регистрации нужно указать учетные данные:

- username - логин персонажа,
- password - пароль.

[^ к оглавлению](#оглавление)

## Авторизация персонажа

Авторизация персонажа проходит посредством токенов.

Получить токен можно стандартным методом, указав в **grant_type** - **person_credentials** и передать логин и пароль.

    {
        "grant_type": "person_credentials",
        "username": "person@mail.com",
        "password": "123456"
    }

Токен персонажа обновляется так же как другие токены.

[^ к оглавлению](#оглавление)

## Привязка персонажей к суперпользователю

Возможно, вы захотите изолировать сущность персонажей от любого пользователя и разрешить их регистрацию только суперпользователям.

Например, сущность персонажей вы будете использовать в системе в качестве операторов или администраторов.

Все, что нужно для этого сделать, это поменять зависимости **private** на **closed**.

[^ к оглавлению](#оглавление)

# Сокеты

Сокеты реализованы в сущности **sockets**.

Для них есть все необходимые сервисы, контроллеры, резолверы.

Несколько пользователей, подключенные через сокеты, могут быть объединены в общую комнату.

[^ к оглавлению](#оглавление)

# Комнаты

Комнаты реализованы в сущности **rooms**.

Для них есть все необходимые сервисы, контроллеры, резолверы.

Комнаты объединяют подключения различных пользователей по сокетам.

[^ к оглавлению](#оглавление)

# Настройки

Настройки реализованы в сущности **settings**.

Для них есть все необходимые сервисы, контроллеры, резолверы.

Настройки сделаны с уровнем защиты **closed**.

Предполагается, что в этой сущности могут храниться настройки вашей системы.

Настройки включают в себя следующие поля:

- name - чтобы задать имя для настройки,
- description - описание или комментарий,
- group - группа настроек,
- type - чтобы задать хранимый тип данных,
- order - позиция для ручной сортировки,
- default - значение по-умолчанию,
- value - значение,
- isDisabled - флаг, который показывает, выключена или нет эта настройка.

Предполагается, что имена должны быть уникальными, однако возможна ситуация, в которой нужно будет хранить настройки с одинаковыми именами, но в разных группах.

Хранимые типы данных задаются в типах настроек. По-умолчанию это:

- null - не задано, по-умолчанию,
- boolean - true/false или 1/0,
- json - объект или массив,
- number - любое числовое значение, целое или дробное,
- string - строка любой длины.

Типы никак не влияют на сами записи в базе, но позволяют вам обрабатывать хранимые данные на стороне клиента.

[^ к оглавлению](#оглавление)

## Группы настроек

Группы позволяют объединять разные настройки.

Группы включают в себя следующие поля:

- name - чтобы задать имя для группы,
- description - описание или комментарий,
- order - позиция для ручной сортировки,
- isDisabled - флаг, который показывает, выключена или нет эта группа.

Благодаря такому механизму можно гибко управлять настройками системы.

[^ к оглавлению](#оглавление)

# Документация

Мы используем документирование методов RestAPI через две связанных библиотеки:

- swagger,
- redoc.

Настройки документации задаются в переменных окружения:

- SWAGGER_PREFIX=swagger
- SWAGGER_PREFIX_REDOC=redoc
- SWAGGER_TITLE=Nest API
- SWAGGER_DESCRIPTION=Nest API documentation
- SWAGGER_VERSION=1.0

SWAGGER_PREFIX и SWAGGER_PREFIX_REDOC задают путь для документации. В данном случае:

    /swagger
    /redoc

соответственно.

Документация управляется декораторами в контроллере.

Декораторы самого контроллера:

@ApiExcludeController() - исключает весь контроллер целиком из документации.

@ApiTags('...') - назначает контроллеру имя в документации.

Декораторы методов контроллера:

@ApiOperation({ summary: '...' }) - описание метода

@ApiParam({ name: '...', required: true/false, description: '...' }) - декоратор параметра, таких декораторов может быть несколько для каждого параметра

@ApiResponse({ status: HttpStatus.OK, description: 'Success', type: ...Dto }) - пример декоратора с описанием ответа от сервера, когда метод отработал без проблем

@ApiResponse({ status: HttpStatus.BAD_REQUEST, description: 'Bad Request' }) - пример декоратора, описывающего ответ сервера в случае ошибки

Декоратор свойств класса dto:

@ApiProperty({ nullable: true/false, description: "...", default: ... })

Доступны следующие опции:

- nullable: true/false,
- description: "...",
- default: ...,
- type: ...,
- enum: ...,
- enumName: ...,
- isArray: true/false - устанавливает мульти-селектор для выбора enum,
- oneOf, anyOf, allOf: [{...}, ...],
- items: {...}

Все декораторы берутся из библотеки

    @nestjs/swagger

Для связанных сущностей в **ApiProperty** используйте в качестве типа поля указание на связанную сущность.

Например:

```
  @ApiProperty({
    type: () => PostsCategoriesDto,
    required: false,
    description: 'Данные категории, связанной с данной записью',
  })
```

```
  @ApiProperty({
    type: () => [PostsDto],
    required: false,
    description: 'Данные записей posts, входящих в данную категорию',
  })
```

[^ к оглавлению](#оглавление)

# Правила именований

## Обычное именование

Для названий всех сущностей мы используем camelCase.

Например:

```
const myConst = ...
function myFunc(firstArgument, secondArgument)...
```

Классы именуются с большой буквы.

[^ к оглавлению](#оглавление)

## Именование в базах данных

Для названия таблиц и полей в базе данных мы используем snake_case.

Например:

```
first_field
second_field
```

Однако в коде js, эти имена преобразуются в camelCase:

```
firstField
secondField
```

[^ к оглавлению](#оглавление)

## Именование сущностей булевого типа

Если переменные, константы или поля объекта являются булевым типом, то в начале их имени ставится **is**.

Например:

```
let isActivated = ...
```

По-умолчанию сущность булевого типа является false (или не задана - null, undefined). Поэтому называя сущность, исходите из этого.

Не стоит использовать в названии отрицания, т.к. это может запутать.

Не стоит называть так функции, даже если они возвращают булев тип.

Плохая практика:

```
let isNotEmpty
if (isRegistered()) ...
```

Хорошая практика:

```
let isAssigned
const isRegistered = verifyRegistration();
if (isRegistered) ...
```

[^ к оглавлению](#оглавление)

## Именование действий

Иногда сущность является действием. Например это функция, метод или константа, которая служит псевдонимом для функции. В таком случае ее имя наверняка будет содержать глагол.

В этом случае глагол выносится вперед.

Например:

```
readUser
```

Могут возникнуть трудности, когда у вас есть несколько похожих сущностей.

Например:

```
userId = readUserId()
userPassword = readUserPassword()
adminId = readAdminId()
adminPassword = readAdminPassword()
```

Появление таких имен сигнализирует о том, что с кодом что-то не так.

В этом случае стоит переписать код и использовать деструктуризацию, чтобы стало вот так:

```
{ userId, userPassword } = readUser()
{ adminId, adminPassword } = readAdmin()
```

Но в идеале стоит задуматься о том, чтобы икапсулировать user и admin в классы.

```
class User {
    id;
    password;

    read () ...
}
```

[^ к оглавлению](#оглавление)

## Именование определений

Определение сущности, главное имя, всегда выносится вперед.

Например:

```
userLogin
userPassword
```

[^ к оглавлению](#оглавление)

## Полное и краткое именование

Не старайтесь максимально сокращать и избегать более полного именования.

Плохая практика:

```
uldt
```

Хорошая практика:

```
userLogoutDatetime
```

В то же время можно сокращать общепринятые термины и понятия, и избавляться от явных вещей.

Плохая практика:

```
const constantSomeInteger
funcGetUserIdentificator(value)
```

Хорошая практика:

```
const someInt
getUserId(val)
```

## Именование файлов

Бывают случаи, когда несколько похожих сущностей лежат в одном каталоге:

```
service
├── adminRead.js
├── adminWrite.js
├── adminCreate.js
├── adminDelete.js
├── userRead.js
├── userWrite.js
├── userCreate.js
└── userDelete.js
```

Появление такой структуры сигнализирует о том, что с ней что-то не так.

В этом случае, возможно, лучшим решением будет поменять всю структуру и использовать классы.

```
service
├── admin
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── user
│   ├── read.js
│   ├── write.js
│   ├── create.js
│   └── delete.js
├── admin.js
└── user.js
```

В файлах **admin.js** и **user.js** импортировать все принадлежащие им функции, а затем собрать их в методы классов и экспортировать.

[^ к оглавлению](#оглавление)

## Именование модулей

Архитектура приложения на **Nest.js** строится на базе модулей.

Структурно модуль представляет каталог с файлами.

Для именования файлов и каталогов модулей рекомедуем использовать нотации kebab-case или snake_case.

Если сущность имеет отдельную таблицу в базе данных или ей требуется отдельный контроллер/резолвер, то такую сущность лучше вынести в отдельный модуль.

Если сущность представляет собой набор сервисных функций и расширяет другой модуль, то эту сущность лучше объединить в этот модуль.

Модули рекомендуем называть в одно слово. Если модуль тесно связан с другим модулем, то рекомендуется использовать общее название.

Например:

```
posts
posts_categories
```

[^ к оглавлению](#оглавление)

### Пример для posts

Файлы внутри каталога будут называться:

```
posts.controller
posts.dto
posts.entity
```

Сущности модуля будут называться:

```
PostsController
PostsDto
PostsEntity
```

Контроллер будет иметь путь:

    /posts

Резолвер будет иметь базовое имя:

    posts

Таблица в базе будет называться:

    posts

[^ к оглавлению](#оглавление)

### Пример для posts_categories

Файлы внутри каталога будут называться:

```
posts_categories.controller
posts_categories.dto
posts_categories.entity
```

Сущности модуля будут называться:

```
PostsCategoriesController
PostsCategoriesDto
PostsCategoriesEntity
```

Контроллер будет иметь путь:

    /posts/categories

Резолвер будет иметь базовое имя:

    postsCategories

Таблица в базе будет называться:

    posts_categories

[^ к оглавлению](#оглавление)

### Внутренняя структура

Базовые сущности модуля стоит поместить в каталоге модуля.

Например:

```
auth
├── auth.controller.js
```

Эта сущность будет иметь название:

- AuthController

Если в модуле есть сущности, расширяющие базовые сущности модуля, их стоит поместить в отдельный каталог.

Например:

```
auth
├── controller
│   └── forms.auth.controller.js
├── auth.controller.js
```

Эта сущность будет иметь название:

- FormsAuthController

Также в отдельный каталог стоит поместить сущности, которые вызываются отдельно.

Например:

```
auth
├── guard
│   ├── gql.auth.guard.js
│   └── jwt.auth.guard.js
```

Эти сущности будут иметь названия:

- GqlAuthGuard,
- JwtAuthGuard.

Иногда название модуля можно опустить.

Но делать это можно только в том случае, если вы уверены, что сущности не будут использоваться за пределами модуля. И их названия не будут пересекаться с названиями таких же сущностей в других модулях.

Например:

```
token
├── grant
│   ├── authorization_code.grant.js
│   └── client_credentials.grant.js
```

Эти сущности будут иметь названия:

- AuthorizationCodeGrant,
- ClientCredentialsGrant.

О общем, схема именования выглядит так:

- название расширения,
- название модуля (можно опустить),
- сущность.

[^ к оглавлению](#оглавление)
